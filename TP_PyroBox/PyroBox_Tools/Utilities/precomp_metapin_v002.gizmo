NoOp {
 name Generate_Cornerpin_flw
 tile_color 0xff5555ff
 selected true
 xpos -21391
 ypos 4766
 addUserKnob {20 User l Export}
 addUserKnob {22 Exportcp l "Generate Cornerpin " T "\nimport nuke\nfrom typing import List, Dict, Union\n\nclass RepositionPoint:\n    def __init__(self, frame_number: int, metadata: Dict\[str, Union\[float, None]]):\n        self.frame_number = frame_number\n        self.metadata = metadata\n\ndef create_cornerpin_from_reposition_points(reposition_points_list: List\[RepositionPoint]) -> None:\n\n    reposition_node = nuke.createNode(\"CornerPin2D\")\n    corner_pin_mapping = \{'One': 'to1', 'Two': 'to2', 'Three': 'to3', 'Four': 'to4'\}\n\n    for corner_pin in corner_pin_mapping.values():\n        reposition_node\[corner_pin].setAnimated()\n\n    for reposition_point in reposition_points_list:\n        frame_number = reposition_point.frame_number\n        metadata = reposition_point.metadata\n        # print(f\"Frame \{frame_number\} Metadata: \{metadata\}\")\n        for word_number, corner_pin in corner_pin_mapping.items():\n            key_x = f\"cpTo\{word_number\}X\"\n            key_y = f\"cpTo\{word_number\}Y\"\n            x_value = metadata.get(key_x, 0)\n            y_value = metadata.get(key_y, 0)\n            reposition_node\[corner_pin].setValueAt(float(x_value), frame_number, 0)\n            reposition_node\[corner_pin].setValueAt(float(y_value), frame_number, 1)\n\n    reposition_node\['from2'].setValue(1024, 0)\n    reposition_node\['from3'].setValue(1024, 0)\n    reposition_node\['from3'].setValue(1024, 1)\n    reposition_node\['from4'].setValue(1024, 1)\n\ndef extract_exr_metadata(read_node: nuke.Node, frame_number: int) -> Union\[Dict\[str, Union\[str, int, float]], None]:\n    try:\n        with nuke.Root():\n            nuke.frame(frame_number)\n            metadata_dict = read_node.metadata()\n        \n        filtered_metadata = \{\}\n        for key in metadata_dict.keys():\n            if key.startswith(\"exr/nuke/cp\"):\n                filtered_metadata\[key.split(\"/\")\[-1]] = metadata_dict\[key]\n\n        return filtered_metadata\n    except Exception as e:\n        print(f\"Error extracting metadata: \{e\}\")\n        return None\n\ndef extract_reposition_points_from_read_node(read_node: nuke.Node) -> List\[RepositionPoint]:\n\n    reposition_points_list = \[]\n\n    original_first_frame = read_node\['first'].value()\n    original_last_frame = read_node\['last'].value()\n\n    for frame_number in range(int(original_first_frame), int(original_last_frame) + 1):\n        read_node\['first'].setValue(frame_number)\n        read_node\['last'].setValue(frame_number)\n\n        metadata = extract_exr_metadata(read_node, frame_number)\n        if metadata:\n            reposition_points_list.append(RepositionPoint(frame_number, metadata))\n    read_node\['first'].setValue(original_first_frame)\n    read_node\['last'].setValue(original_last_frame)\n\n    return reposition_points_list\n\ndef find_top_read_node(node: nuke.Node) -> Union\[nuke.Node, None]:\n    if node.Class() == \"Read\":\n        return node\n\n    input_nodes = node.dependencies(nuke.INPUTS)\n    if not input_nodes:\n        return None\n\n    for input_node in input_nodes:\n        read_node = find_top_read_node(input_node)\n        if read_node:\n            return read_node\n    return None\n\nif __name__ == \"__main__\":\n    current_node = nuke.thisNode()\n\n    top_read_node = find_top_read_node(current_node)\n    if top_read_node:\n        reposition_points_list = extract_reposition_points_from_read_node(top_read_node)\n        create_cornerpin_from_reposition_points(reposition_points_list)\n    else:\n        nuke.message(\"No top-level Read node found.\")\n" +STARTLINE}
}
