set cut_paste_input [stack 0]
version 14.0 v6
Group {
 inputs 0
 name EZ_RotoTracker1
 knobChanged "import nuke\nimport nuke.rotopaint as rp\n\ngroup = nuke.thisNode()\nknob = nuke.thisKnob()\ntrackerName = group\['trackerName'].value()\ntracker_node = nuke.toNode(trackerName)\nrotoName = group\['rotoName'].value()\nroto_node = nuke.toNode(rotoName)\n\n\n#    if roto_node.Class() not in ('Roto', 'RotoPaint'):\n\nif \"trackerName\" in knob.name():\n    if tracker_node is None:\n        group\['trackerName'].setLabel(\"<font color=#FA466A><b> ><b\\>\")\n        group\['exists'].setValue(False)\n        nuke.thisNode()\['first_frame'].setValue(0)\n        nuke.thisNode()\['last_frame'].setValue(0)                  \n            \n    else:\n        group\['trackerName'].setLabel(\" >\")\n        group\['exists'].setValue(True)        \n        translate_knob = tracker_node\['translate']\n        translate_curve = translate_knob.animation(0)        \n        first_frame = int(translate_curve.keys()\[0].x)\n        last_frame = int(translate_curve.keys()\[-1].x)        \n        nuke.thisNode()\['first_frame'].setValue(first_frame)\n        nuke.thisNode()\['last_frame'].setValue(last_frame)\n        \nif \"rotoName\" in knob.name():\n    if roto_node is None:     \n        group\['rotoName'].setLabel(\"<font color=#FA466A><b> ><b\\>\")\n        group\['exists_2'].setValue(False)   \n    else:\n        group\['rotoName'].setLabel(\" >\")\n        group\['exists_2'].setValue(True)\n        first_frame = nuke.root().firstFrame()\n        last_frame = nuke.root().lastFrame()        \n        group\['first_frame'].setValue(first_frame)\n        group\['last_frame'].setValue(last_frame)    \n        print(f\"Range is now \{first_frame\} to \{last_frame\}\")                            \n        \nif knob.name() == \"choice\":\n    print(knob.value())\n    if knob.value() == \"Tracker > Roto\":\n        group\['rotoName'].setValue(\"\")\n        group\['text_1'].setVisible(True)\n        group\['trackerName'].setVisible(True)\n        group\['SelectTracker'].setVisible(True)                                \n        group\['createRoto'].setVisible(True)\n        group\['exists'].setVisible(True)    \n        group\['exists'].setValue(False)             \n        group\['createTracker'].setVisible(False)   \n        group\['rotoName'].setVisible(False)      \n        group\['selectRoto'].setVisible(False)  \n        group\['rotoText'].setVisible(False) \n        group\['exists_2'].setVisible(False)         \n        nuke.thisNode()\['first_frame'].setValue(0)\n        nuke.thisNode()\['last_frame'].setValue(0)   \n        group\['trackerName'].setLabel(\"<font color=#FA466A><b> ><b\\>\")      \n        group\['tile_color'].setValue(int('%02x%02x%02x%02x' % (204, 204, 204, 255), 16))\n        group\['label'].setValue(\"Tracker to Roto\")                                          \n\n    \n    \n    if knob.value() == \"Roto Points > Tracker\":\n        group\['trackerName'].setValue(\"\")        \n        group\['text_1'].setVisible(False)\n        group\['trackerName'].setVisible(False)\n        group\['SelectTracker'].setVisible(False)                               \n        group\['createRoto'].setVisible(False) \n        group\['exists'].setVisible(False)   \n        group\['exists_2'].setVisible(True)                \n        group\['exists_2'].setValue(False)       \n        group\['createTracker'].setVisible(True)  \n        group\['rotoName'].setVisible(True)      \n        group\['selectRoto'].setVisible(True)     \n        group\['rotoText'].setVisible(True)             \n        group\['first_frame'].setValue(nuke.root().firstFrame())\n        group\['last_frame'].setValue(nuke.root().lastFrame())  \n        group\['rotoName'].setLabel(\"<font color=#FA466A><b> ><b\\>\")  \n        group\['tile_color'].setValue(int('%02x%02x%02x%02x' % (112, 196, 112, 255), 16))    \n        group\['label'].setValue(\"Roto to Tracker\")         "
 tile_color 0xccccccff
 label "Tracker to Roto"
 selected true
 xpos 304
 ypos -499
 addUserKnob {20 User l Controls}
 addUserKnob {4 choice l "" +STARTLINE M {"Tracker > Roto" "Roto Points > Tracker" "" "" "" "" ""}}
 addUserKnob {26 text_1 l "@b;Track Node"}
 addUserKnob {1 trackerName l "<font color=#FA466A><b> ><b\\>"}
 addUserKnob {22 SelectTracker l Select -STARTLINE T "group = nuke.thisNode()\nwith nuke.root():\n\tTracker = nuke.selectedNode()\['name'].value()\ngroup\['trackerName'].setValue(Tracker)"}
 addUserKnob {6 exists -STARTLINE +INVISIBLE}
 addUserKnob {26 rotoText l "@b;Roto Node" +HIDDEN}
 addUserKnob {1 rotoName l "<font color=#FA466A><b> ><b\\>" +HIDDEN}
 addUserKnob {22 selectRoto l Select -STARTLINE +HIDDEN T "group = nuke.thisNode()\nwith nuke.root():\n\tRoto = nuke.selectedNode()\['name'].value()\ngroup\['rotoName'].setValue(Roto)"}
 addUserKnob {6 exists_2 l exists -STARTLINE +HIDDEN +INVISIBLE}
 addUserKnob {26 ""}
 addUserKnob {3 first_frame l "@b;Set Range"}
 addUserKnob {3 last_frame l - -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {22 createRoto l "Create Roto!" T "import nuke, _curvelib as cl\n\ngroup = nuke.thisNode()\ntracker_exists = group\['exists'].value()\n\nif tracker_exists:\n    \n    tracker_name = group\['trackerName'].value()\n    tracker_node = nuke.toNode(tracker_name)\n    \n    nuke.root().begin()\n    nukescripts.clear_selection_recursive()\n    tracker_node.setSelected(True)\n    roto_node = nuke.createNode('Roto')\n    roto_node.setName(tracker_name+\"_Roto1\")\n    \n    curves_knob = roto_node\[\"curves\"]\n    new_layer = nuke.rotopaint.Layer(curves_knob)\n    new_layer.name = tracker_name\n    \n    first_frame = int(group\['first_frame'].value())\n    last_frame = int(group\['last_frame'].value())\n    \n    curves = \[cl.AnimCurve() for _ in range(7)]\n    for curve in curves:\n        curve.useExpression = True\n    \n    # Set the expression strings\n    expressions = \[\"parent.\{0\}.translate.x\", \"parent.\{0\}.translate.y\", \"parent.\{0\}.rotate\", \"parent.\{0\}.scale.w\", \"parent.\{0\}.scale.h\", \"parent.\{0\}.center.x\", \"parent.\{0\}.center.y\"]\n    for curve, expr in zip(curves, expressions):\n        curve.expressionString = expr.format(tracker_name)\n    \n    \n    transform_attr = new_layer.getTransform()\n    \n    transform_attr.setTranslationAnimCurve(0, curves\[0])\n    transform_attr.setTranslationAnimCurve(1, curves\[1])\n    transform_attr.setRotationAnimCurve(2, curves\[2])\n    transform_attr.setScaleAnimCurve(0, curves\[3])\n    transform_attr.setScaleAnimCurve(1, curves\[4])\n    transform_attr.setPivotPointAnimCurve(0, curves\[5])\n    transform_attr.setPivotPointAnimCurve(1, curves\[6])\n    \n    curves_knob.rootLayer.append(new_layer)\n    \n    \n    get_curve_methods = \[\n        transform_attr.getTranslationAnimCurve,\n        transform_attr.getTranslationAnimCurve,\n        transform_attr.getRotationAnimCurve,\n        transform_attr.getScaleAnimCurve,\n        transform_attr.getScaleAnimCurve,    \n        transform_attr.getPivotPointAnimCurve,\n        transform_attr.getPivotPointAnimCurve\n    ]\n    \n    indexes = \[0, 1, 2, 0, 1, 0, 1]\n    \n    for get_curve_method, index in zip(get_curve_methods, indexes):\n        print(expressions\[index])\n        curve = get_curve_method(index)\n        if curve.expressionString != \"\":\n            print(\"True dat\")\n            for frame in range(first_frame, last_frame + 1):\n                value = curve.evaluate(frame)\n                curve.addKey(frame, value)\n        curve.expressionString = \"curve\"\n        \nelse:\n    nuke.message('Woopsie, no Tracker named \"\{0\}\" exists in this script'.format(tracker_name))" +STARTLINE}
 addUserKnob {22 createTracker l "Create Tracker!" -STARTLINE +HIDDEN T "import nuke, nuke.rotopaint as rp, math\n\n\ngroup = nuke.thisNode() \nrotoName = group\['rotoName'].value()\n\n\nnuke.root().begin()\n\n\ndef traverse_objects(obj, object_list):\n    for item in obj:\n        attributes = item.getAttributes()  \n        if isinstance(item, nuke.rotopaint.Shape):\n            object_list.append(\[item, obj]) \n        if isinstance(item, nuke.rotopaint.Layer):\n            object_list.append(\[item, obj])\n            traverse_objects(item, object_list)\n    return object_list\n\ndef apply_transform_matrix(point, transform, frame):\n    transformation_matrix = transform.evaluate(frame).getMatrix()\n    vector = nuke.math.Vector4(point\[0], point\[1], 1, 1)\n    x = (vector\[0] * transformation_matrix\[0]) + (vector\[1] * transformation_matrix\[1]) + transformation_matrix\[2] + transformation_matrix\[3]\n    y = (vector\[0] * transformation_matrix\[4]) + (vector\[1] * transformation_matrix\[5]) + transformation_matrix\[6] + transformation_matrix\[7]\n    z = (vector\[0] * transformation_matrix\[8]) + (vector\[1] * transformation_matrix\[9]) + transformation_matrix\[10] + transformation_matrix\[11]\n    w = (vector\[0] * transformation_matrix\[12]) + (vector\[1] * transformation_matrix\[13]) + transformation_matrix\[14] + transformation_matrix\[15]\n    vector = nuke.math.Vector4(x, y, z, w)\n    vector = vector / w\n    return vector\n\ndef transform_layers(point, layer, frame, root_layer, shape_list):\n    if layer == root_layer:\n        transformation = layer.getTransform()\n        new_point = apply_transform_matrix(point, transformation, frame)\n    else:\n        transformation = layer.getTransform()\n        new_point = apply_transform_matrix(point, transformation, frame)\n        for shape in shape_list: \n            if shape\[0] == layer:\n                new_point = transform_layers(new_point, shape\[1], frame, root_layer, shape_list)\n    return new_point\n\ndef convert_roto_shapes_to_trackers():\n    roto_node_name = rotoName\n    roto_node = nuke.toNode(rotoName)\n    if roto_node.Class() not in ('Roto', 'RotoPaint'):\n        if nuke.GUI:\n            nuke.message('Unsupported node type. Selected Node must be Roto or RotoPaint')\n\n    first_frame = group\['first_frame'].value()\n    print(first_frame)\n    last_frame = group\['last_frame'].value()\n    print(last_frame)\n    frame_range = nuke.FrameRange(int(first_frame), int(last_frame), int(1))\n    roto_curve = roto_node\['curves']\n    root_layer = roto_curve.rootLayer\n    shape_list = \[]\n    shape_list = traverse_objects(root_layer, shape_list)\n    cancel = False\n    for shape in shape_list:\n        if isinstance(shape\[0], nuke.rotopaint.Shape):\n            if cancel:\n                break\n            count = 0\n            tracker_list = \[]\n            positions_list = \[]\n            task = nuke.ProgressTask('Converting Roto')\n            \n            for points in shape\[0]:\n                positions_list.append(\[]) \n  \n            for frame in range(int(first_frame), int(last_frame)+1):\n                tracker_index = 0\n                for points in shape\[0]:\n                    if task.isCancelled():\n                        cancel = True\n                        break \n                    if cancel:\n                        break\n                    point = \[points.center.getPosition(frame)\[0], points.center.getPosition(frame)\[1]]\n                    transform = shape\[0].getTransform()\n                    xy = apply_transform_matrix(point, transform, frame)\n                    xy = transform_layers(xy, shape\[1], frame, root_layer, shape_list)\n                    positions_list\[tracker_index].append(xy)\n                    tracker_index += 1;\n            tracker_index = 0\n            nukescripts.clear_selection_recursive()\n            roto_node.setSelected(True)            \n            tracker_node = nuke.createNode('Tracker4')\n            print(\"ok\")\n            tracker_node.setName(roto_node.name()+\"_Tracker1\")            \n            for position in positions_list:\n                if task.isCancelled():\n                    cancel = True\n                    break                \n                if cancel:\n                    break\n                k = tracker_node\['tracks']\n                num_columns = 31\n                col_track_x = 2\n                col_track_y = 3\n                tracker_node\[\"add_track\"].execute()\n                track_index = tracker_index\n                count = 0\n                for frame in range(int(first_frame), int(last_frame)+1):\n                    if task.isCancelled():\n                        cancel = True\n                        break   \n                    task.setProgress(int(((float(frame) - int(first_frame))+1 / (int(last_frame) - int(first_frame)+1)* 100)))\n                    k.setValueAt(position\[count]\[0],frame, num_columns*track_index + col_track_x)\n                    k.setValueAt(position\[count]\[1],frame,num_columns*track_index + col_track_y)                \n                    k.setValueAt(1, frame, num_columns*track_index + 6) # Translate\n                    k.setValueAt(1, frame, num_columns*track_index + 7) # Scale\n                    k.setValueAt(1, frame, num_columns*track_index + 8) # Rotate                    \n                    count += 1\n                if not frame_range.isInRange(nuke.frame()):\n                    for n in range(num_columns): \n                        k.removeKeyAt(nuke.frame(),num_columns*track_index + n)                \n                tracker_index += 1;\n\nif __name__ == '__main__':\n    convert_roto_shapes_to_trackers()\n"}
 addUserKnob {26 ""}
 addUserKnob {26 About l "" +STARTLINE T "<font size=3> v1.2.1 | <font size=1> Victor Rouillard &copy; "}
}
 Output {
  inputs 0
  name Output1
  xpos 0
  ypos 300
 }
end_group
