#! C:/Program Files/Nuke15.0v2/nuke-15.0.2.dll -nx
version 15.0 v2
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="3839" y="-6" w="1920" h="1033" maximized="1" screen="1">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1257" stretch="1"/>
            <splitter orientation="2">
                <split size="582"/>
                <dock id="" activePageId="Viewer.1" focus="true">
                    <page id="Viewer.1"/>
                </dock>
                <split size="409"/>
                <dock id="" activePageId="DAG.1">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
                <page id="Scenegraph.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name E:/Apps/Nuke/FlowPaint/Nuke15_0v5_Demoscript/Script_Updated.nk
 project_directory "\[python \{nuke.script_directory()\}]"
 frame 58
 first_frame 15
 last_frame 500
 lock_range true
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement OCIO
 OCIO_config aces_1.2
 defaultViewerLUT "OCIO LUTs"
 workingSpaceLUT scene_linear
 monitorLut "sRGB (ACES)"
 monitorOutLUT "sRGB (ACES)"
 int8Lut matte_paint
 int16Lut texture_paint
 logLut compositing_log
 floatLut scene_linear
}
BackdropNode {
 inputs 0
 name BackdropNode10
 tile_color 0x388e8e00
 label "normalized samples\n(heavier, but distortion is more evenly spaced"
 note_font_size 42
 xpos 2042
 ypos 959
 bdwidth 578
 bdheight 290
 z_order -1
}
BackdropNode {
 inputs 0
 name BackdropNode5
 tile_color 0x388e8e00
 note_font_size 42
 xpos 1200
 ypos 231
 bdwidth 714
 bdheight 351
 z_order -1
}
BackdropNode {
 inputs 0
 name BackdropNode6
 tile_color 0x388e8e00
 note_font_size 42
 xpos 2207
 ypos 257
 bdwidth 578
 bdheight 290
 z_order -1
}
BackdropNode {
 inputs 0
 name BackdropNode1
 tile_color 0x8384c6ff
 label "save\nthis\nin toolset"
 xpos -155
 ypos -446
 bdwidth 130
 bdheight 110
}
BackdropNode {
 inputs 0
 name BackdropNode11
 tile_color 0x8384c6ff
 label "save\nthis\nin toolset"
 xpos 2052
 ypos 1129
 bdwidth 130
 bdheight 110
}
BackdropNode {
 inputs 0
 name BackdropNode12
 tile_color 0x71c67100
 label "wider format, only in\n\"X\""
 note_font_size 15
 xpos 2396
 ypos 1131
 bdwidth 214
 bdheight 106
}
BackdropNode {
 inputs 0
 name BackdropNode13
 tile_color 0x8384c6ff
 label "save\nthis\nin toolset"
 xpos -144
 ypos 357
 bdwidth 130
 bdheight 110
}
BackdropNode {
 inputs 0
 name BackdropNode14
 tile_color 0x8e8e3800
 label "\"tight\" curves example\n"
 note_font_size 42
 xpos -146
 ypos 695
 bdwidth 458
 bdheight 341
}
BackdropNode {
 inputs 0
 name BackdropNode15
 tile_color 0x71c67100
 label "shift me from\nleft to right\nto make\nme FLOW\n\n(in transform tab of noise, \"X\")"
 note_font_size 22
 xpos 30
 ypos 238
 bdwidth 367
 bdheight 324
}
BackdropNode {
 inputs 0
 name BackdropNode2
 tile_color 0x71c67100
 label "this node \nis also useful\nfor repeated motions\n\nshift \"X\" to make me slide around"
 note_font_size 15
 xpos 189
 ypos -444
 bdwidth 254
 bdheight 123
}
BackdropNode {
 inputs 0
 name BackdropNode3
 tile_color 0x8384c6ff
 label "save\nthis\nin toolset"
 xpos 1210
 ypos 401
 bdwidth 130
 bdheight 110
}
BackdropNode {
 inputs 0
 name BackdropNode4
 tile_color 0x71c67100
 label "squeezing \"X\" to be\nreally small.  works for small stuff,\nprobably not great quality for closer to camera stuff"
 note_font_size 15
 xpos 1554
 ypos 403
 bdwidth 391
 bdheight 109
}
BackdropNode {
 inputs 0
 name BackdropNode7
 tile_color 0x8384c6ff
 label "save\nthis\nin toolset"
 xpos 2217
 ypos 427
 bdwidth 130
 bdheight 110
}
BackdropNode {
 inputs 0
 name BackdropNode8
 tile_color 0x71c67100
 label "wider format, only in\n\"X\""
 note_font_size 15
 xpos 2561
 ypos 429
 bdwidth 214
 bdheight 106
}
BackdropNode {
 inputs 0
 name BackdropNode9
 tile_color 0x388e8e00
 label "dont want stretching like this frame?\n(FRAME 29)\n\n"
 note_font_size 42
 xpos 1997
 ypos 673
 bdwidth 718
 bdheight 171
}
StickyNote {
 inputs 0
 name StickyNote4
 label "Matching the resolution (The Width) of the input image, to the \"length\" of the string you draw"
 note_font_size 15
 xpos 2179
 ypos 150
}
StickyNote {
 inputs 0
 name StickyNote7
 tile_color 0x666dccff
 label "Faster Computationally, Lower Quality"
 note_font_size 15
 xpos 1492
 ypos 180
}
ColorWheel {
 inputs 0
 gamma 0.45
 name ColorWheel3
 xpos 2517
 ypos 1036
}
Reformat {
 type scale
 scale {7 1}
 resize none
 name Reformat2
 xpos 2510
 ypos 1185
}
Group {
 name Offset2
 xpos 2510
 ypos 1209
 addUserKnob {20 User l Offset}
 addUserKnob {12 offset}
 offset {{curve x1 0 x100 13900} {curve x1 0}}
 addUserKnob {14 tiles R 0 100}
 tiles 1
 addUserKnob {6 mx l "mirror x" +STARTLINE}
 addUserKnob {6 my l "mirror y" -STARTLINE}
 addUserKnob {41 filter T STMap1.filter}
 addUserKnob {26 ""}
 addUserKnob {41 motionblur T mb_trans.motionblur}
 addUserKnob {41 shutter T mb_trans.shutter}
 addUserKnob {41 shutteroffset l "shutter offset" T mb_trans.shutteroffset}
 addUserKnob {41 shuttercustomoffset l "" -STARTLINE T mb_trans.shuttercustomoffset}
 addUserKnob {20 about l @}
 addUserKnob {26 author l "Author: " T "Mariusz Wesierski ( mw@fxcalibur.com )"}
 addUserKnob {26 version l "Version: " T 1.0}
}
 Input {
  inputs 0
  name Input1
  xpos -301
  ypos -196
 }
set Nac2dec00 [stack 0]
 Expression {
  expr0 ((x-offset.x)<0?1+((x-offset.x)/width*tiles.w)-int((x-offset.x)/width*tiles.w):((x-offset.x)/width*tiles.w)-int((x-offset.x)/width*tiles.w))
  expr1 ((y-offset.y)<0?1+((y-offset.y)/height*tiles.h)-int((y-offset.y)/height*tiles.h):((y-offset.y)/height*tiles.h)-int((y-offset.y)/height*tiles.h))
  expr2 0
  channel3 {none none none -rgba.alpha}
  name offset_xp
  xpos -422
  ypos -142
 }
 Expression {
  expr0 "mx?(x-offset.x>=0?0:1)+ fmod(int((x-offset.x)/width*tiles.w),2)!=0?1-r:r:r"
  expr1 "my?(y-offset.y>=0?0:1)+ fmod(int((y-offset.y)/height*tiles.h),2)!=0?1-g:g:g"
  channel2 {-rgba.red -rgba.green -rgba.blue none}
  channel3 none
  name mirror_xp
  xpos -422
  ypos -118
  disable {{mx?0:my?0:1}}
 }
push $Nac2dec00
 STMap {
  inputs 2
  uv rgb
  blur_scale 0
  filter impulse
  name STMap1
  xpos -301
  ypos -124
 }
 Transform {
  translate {{offset.x i} {offset.y i}}
  center {800 501.5}
  filter impulse
  shutteroffset centred
  name mb_trans
  xpos -301
  ypos -81
  disable {{motionblur>0?0:1 i}}
 }
 Transform {
  translate {{-offset.x i} {-offset.y i}}
  center {800 501.5}
  filter impulse
  black_outside false
  name inv_trans
  xpos -301
  ypos -57
  disable {{mb_trans.motionblur>0?0:1 i}}
 }
 Output {
  name Output1
  xpos -301
  ypos -23
 }
end_group
Roto {
 inputs 0
 output alpha
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097664}
    {t x44800000 x44428000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup OpenSpline1 1049088 bezier
     {{cc
       {f 1056800}
       {px
        {x41e80000 x43340000}
        {{xc0e00000}
      {xc2940000}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {x42a60000}
      {x44138000}}
        {{x40e00000}
      {x42940000}}
        {{xc1f80000}
      {xc29a0000}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {x42fa0000}
      {x446d0000}}
        {{x41f80000}
      {x429a0000}}
        {{xc2820000}
      {xc1a00000}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {x43bb8000}
      {x4491e000}}
        {{x42820000}
      {x41a00000}}
        {{xc1400000}
      {x41b80000}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {x44220000}
      {x4480a000}}
        {{x41400000}
      {xc1b80000}}
        {{0}
      {0}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {x442c8000}
      {x441e4000}}
        {{0}
      {0}}
        {{0}
      {0}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {x444d4000}
      {x43f18000}}
        {{0}
      {0}}
        {{0}
      {xc1d80000}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {x44710000}
      {x43e00000}}
        {{0}
      {x41d80000}}
        {{xc0800000}
      {xc1d80000}}
        {{a osw
       {{x41e80000 1 -}
        {x43340000}}	 osf
       {{x41e80000 0 -}
        {x43340000}}}
      {{x44840000 -}}
      {{x44250000 -}}}
        {{{x40199800 0 1 x3c2d9dab 1}
       {x40199800 x3c2d9dab 1 0 1}}
      {{x41819980 0 1 x3d927aea 1}
       {x41819980 x3d927aea 1 0 1}}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {xc25a1cc0}
      {xc2b1fbf0}}
        {{a osw
       {{x41e80000 1 -}
        {x43340000}}	 osf
       {{x41e80000 0 -}
        {x43340000}}}
      {{x44938000 -}
       {x4493b22e -}}
      {{x445c4ccd -}
       {x445beb02 -}}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {x42116860}
      {x426d4fe0}}
        {{{0 -}}
      {{0 -}}}
        {{a osw
       {{x41e80000 1 -}
        {x43340000}}	 osf
       {{x41e80000 0 -}
        {x43340000}}}
      {{x449c0000 -}}
      {{x4476c000 -}}}
        {{0}
      {0}}
        {{0}
      {0}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {x44b68000}
      {x4487e000}}
        {{0}
      {0}}
        {{0}
      {0}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {x44dfe000}
      {x4481a000}}
        {{0}
      {0}}}}
      {cc
       {f 1056800}
       {px
        {x41e80000 x43340000}
        {{xc0e00000}
      {xc2940000}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {0}
      {0}}
        {{x40e00000}
      {x42940000}}
        {{xc1f80000}
      {xc29a0000}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {0}
      {0}}
        {{x41f80000}
      {x429a0000}}
        {{xc2820000}
      {xc1a00000}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {0}
      {0}}
        {{x42820000}
      {x41a00000}}
        {{xc1400000}
      {x41b80000}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {0}
      {0}}
        {{x41400000}
      {xc1b80000}}
        {{0}
      {0}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {0}
      {0}}
        {{0}
      {0}}
        {{0}
      {0}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {0}
      {0}}
        {{0}
      {0}}
        {{0}
      {xc1d80000}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {0}
      {0}}
        {{0}
      {x41d80000}}
        {{xc0800000}
      {xc1d80000}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {0}
      {0}}
        {{x40199800}
      {x41819980}}
        {{a osw
       {{x41e80000 1 -}
        {x43340000}}	 osf
       {{x41e80000 0 -}
        {x43340000}}}
      {{xc25a1cc0 0 1 x40fa6607 1}
       {xc25a1cc0 x40fa6607 1 0 1}}
      {{xc2b1fbf0 0 1 x40ba6baa 1}
       {xc2b1fbf0 x40ba6baa 1 0 1}}}
        {{a osw
       {{x41e80000 1 -}
        {x43340000}}	 osf
       {{x41e80000 0 -}
        {x43340000}}}
      {{0 0 1 x40fa6607 1}
       {0 x40fa6607 1 0 1}}
      {{0 0 1 x40ba6baa 1}
       {0 x40ba6baa 1 0 1}}}
        {{a osw
       {{x41e80000 1 -}
        {x43340000}}	 osf
       {{x41e80000 0 -}
        {x43340000}}}
      {{x42116860 0 1 x40fa6607 1}
       {x42116860 x40fa6607 1 0 1}}
      {{x426d4fe0 0 1 x40ba6baa 1}
       {x426d4fe0 x40ba6baa 1 0 1}}}
        {{0}
      {0}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {0}
      {0}}
        {{0}
      {0}}
        {{0}
      {0}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {0}
      {0}}
        {{0}
      {0}}
        {{0}
      {0}}
        {{a osw
       {{x41e80000 1}
        {x43340000}}	 osf
       {{x41e80000 0}
        {x43340000}}}
      {0}
      {0}}
        {{0}
      {0}}}}}
     {tx x43340000 x44527a2f x444e1d17}
     {a osbe 0 osee 0 osw x41200000 osf 0 str 1 ltn x43340000 ltm x43340000 tt x41200000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createOpenSpline str 1 ssx 1 ssy 1 sf 1 tt 10 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {320 240}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 lifetime_start 180
 lifetime_end 180
 motionblur_shutter_offset_type centred
 name Roto3
 xpos 2062
 ypos 1084
}
Group {
 inputs 2
 name CA_FlowWarp2
 tile_color 0x4c65ffff
 note_font "Verdana Bold"
 note_font_size 12
 note_font_color 0xe0cc30ff
 xpos 1948
 ypos 1207
 addUserKnob {20 User}
 addUserKnob {41 format T BlinkScript.format}
 addUserKnob {26 d l " " T "Make sure format matches roto"}
 addUserKnob {26 ""}
 addUserKnob {22 SampleRoto l "Sample Roto" T "import nuke\nimport nuke.rotopaint as rp\n\n# Function to retrieve points from the Roto node's shapes and strokes\ndef get_roto_points(roto_node):\n    curves_knob = roto_node\['curves']\n    points = \[]\n    processed_elements = set()  # To track processed elements\n\n    # Access the root layer of the Roto node\n    root_layer = curves_knob.rootLayer\n\n    # Function to parse the layer and find shapes and strokes\n    def parse_layer(layer):\n        for element in layer:\n            element_id = id(element)  # Unique identifier for each element\n\n            # Check if the element is a Shape and not already processed\n            if isinstance(element, rp.Shape) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark element as processed\n\n                # Loop through the control points (CVs) in the shape\n                for point_idx, point in enumerate(element):\n                    frame = nuke.frame()\n                    # Get the position of the control vertex (center point)\n                    pos = point.center.getPosition(frame)\n                    points.append((pos\[0], pos\[1]))\n\n            # If the element is a Layer, process its contents\n            elif isinstance(element, rp.Layer) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark layer as processed\n                parse_layer(element)  # Recursively parse nested layers\n\n    # Parse the root layer to extract points\n    parse_layer(root_layer)\n    \n    return points\n\n# Main function to run the script and update the BlinkScript node\ndef main():\n    # Get the current node (the group node)\n    current_node = nuke.thisNode()\n\n    # Check if there is an input connected to the node (assuming input 0 is the roto node)\n    roto_node = current_node.input(0)\n    \n    if not roto_node or roto_node.Class() not in \['Roto', 'RotoPaint']:\n        nuke.message(\"Please connect a Roto or RotoPaint node to the current node.\")\n        return\n\n    # Get the points from the connected Roto or RotoPaint node\n    roto_points = get_roto_points(roto_node)\n    \n    if not roto_points:\n        nuke.message(\"No points found in the connected Roto node.\")\n        return\n    else:\n        # Begin the group to access internal nodes\n        current_node.begin()\n        # Find the BlinkScript node inside the group\n        blinkscript_node = None\n        blinkscript_node = nuke.toNode(current_node.name()+\".Dot_FW\").input(0)\n        \n        if blinkscript_node is None:\n            nuke.message(\"BlinkScript node not found inside the group.\")\n            current_node.end()\n            return\n\n        # Update the BlinkScript node parameters\n        # Set \"Number of Control Points\" to the number of points retrieved\n        blinkscript_node\['SplineUVMap_Number of Control Points'].setValue(len(roto_points))\n        # Update the positions of the points\n        max_points = 50  # Updated to support up to 50 points\n        for idx, point in enumerate(roto_points):\n            if idx >= max_points:\n                nuke.warning(f\"BlinkScript node supports a maximum of \{max_points\} points. Extra points are ignored.\")\n                break\n            # The point knobs are named \"SplineUVMap_Point0\", \"SplineUVMap_Point1\", etc.\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue(point)\n            else:\n                nuke.warning(f\"BlinkScript node does not have knob \{knob_name\}\")\n\n        # For any remaining Point knobs, set them to (0, 0)\n        for idx in range(len(roto_points), max_points):\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue((0.0, 0.0))\n\n        # End the group\n        current_node.end()\n\n# Execute the main function\nmain()" +STARTLINE}
 addUserKnob {41 "SplineUVMap_Number of Samples_1" l "Number of Samples" T "BlinkScript.SplineUVMap_Number of Samples"}
 addUserKnob {41 "SplineUVMap_Max Distance" l "Max Distance" T "BlinkScript.SplineUVMap_Max Distance"}
 addUserKnob {7 UVBLUR l "UV Blur" R 0 50}
 addUserKnob {41 "SplineUVMap_Curve Tightness" l "Curve Tightness" T "BlinkScript.SplineUVMap_Curve Tightness"}
 addUserKnob {41 "SplineUVMap_Normalize Samples" l "Normalize Samples" T "BlinkScript.SplineUVMap_Normalize Samples"}
 addUserKnob {26 explanation l Samples T "If you want your\nsamples evenly spread,\nnormalize them"}
 addUserKnob {26 ""}
 addUserKnob {41 "SplineUVMap_Number of Control Points" l "Number of Control Points" T "BlinkScript.SplineUVMap_Number of Control Points"}
 addUserKnob {26 _1 l Info: T "Auto detected from Sample Roto.  \nYou can put custom control points\nin group if you want."}
 addUserKnob {26 ""}
 addUserKnob {26 tapers l " " T "Taper Controls"}
 addUserKnob {41 "SplineUVMap_Width Start" l "Width Start" T "BlinkScript.SplineUVMap_Width Start"}
 addUserKnob {41 "SplineUVMap_Width Center" l "Width Center" T "BlinkScript.SplineUVMap_Width Center"}
 addUserKnob {41 "SplineUVMap_Width End" l "Width End" T "BlinkScript.SplineUVMap_Width End"}
 addUserKnob {26 ""}
 addUserKnob {26 Edge l "" -STARTLINE T "Edge Details"}
 addUserKnob {41 size l "Erode Edge" T FilterErode1.size}
 addUserKnob {41 filter l "Edge Filter" T FilterErode1.filter}
 addUserKnob {26 ""}
 addUserKnob {26 compacademy l " " T "For more:\nTools, Training, Epic Stock Footage:\n\nwww.compositingacademy.com\n\nMade in 2024"}
}
 BlinkScript {
  inputs 0
  recompileCount 2
  ProgramGroup 1
  KernelDescription "3 \"SplineUVMap\" iterate pixelWise 7323e521568e7c81daf69ed13b674e934e88cc6f9c6cb7a338b61e69790b719a 1 \"dst\" Write Point 58 \"Number of Control Points\" Int 1 BAAAAA== \"Number of Samples\" Int 1 ZAAAAA== \"Max Distance\" Float 1 AABIQg== \"Curve Tightness\" Float 1 AAAAAA== \"Width Start\" Float 1 AACAPw== \"Width Center\" Float 1 AACAPw== \"Width End\" Float 1 AACAPw== \"Normalize Samples\" Bool 1 AA== \"Point0\" Float 2 AAAAAAAAAAA= \"Point1\" Float 2 AAAAAAAAAAA= \"Point2\" Float 2 AAAAAAAAAAA= \"Point3\" Float 2 AAAAAAAAAAA= \"Point4\" Float 2 AAAAAAAAAAA= \"Point5\" Float 2 AAAAAAAAAAA= \"Point6\" Float 2 AAAAAAAAAAA= \"Point7\" Float 2 AAAAAAAAAAA= \"Point8\" Float 2 AAAAAAAAAAA= \"Point9\" Float 2 AAAAAAAAAAA= \"Point10\" Float 2 AAAAAAAAAAA= \"Point11\" Float 2 AAAAAAAAAAA= \"Point12\" Float 2 AAAAAAAAAAA= \"Point13\" Float 2 AAAAAAAAAAA= \"Point14\" Float 2 AAAAAAAAAAA= \"Point15\" Float 2 AAAAAAAAAAA= \"Point16\" Float 2 AAAAAAAAAAA= \"Point17\" Float 2 AAAAAAAAAAA= \"Point18\" Float 2 AAAAAAAAAAA= \"Point19\" Float 2 AAAAAAAAAAA= \"Point20\" Float 2 AAAAAAAAAAA= \"Point21\" Float 2 AAAAAAAAAAA= \"Point22\" Float 2 AAAAAAAAAAA= \"Point23\" Float 2 AAAAAAAAAAA= \"Point24\" Float 2 AAAAAAAAAAA= \"Point25\" Float 2 AAAAAAAAAAA= \"Point26\" Float 2 AAAAAAAAAAA= \"Point27\" Float 2 AAAAAAAAAAA= \"Point28\" Float 2 AAAAAAAAAAA= \"Point29\" Float 2 AAAAAAAAAAA= \"Point30\" Float 2 AAAAAAAAAAA= \"Point31\" Float 2 AAAAAAAAAAA= \"Point32\" Float 2 AAAAAAAAAAA= \"Point33\" Float 2 AAAAAAAAAAA= \"Point34\" Float 2 AAAAAAAAAAA= \"Point35\" Float 2 AAAAAAAAAAA= \"Point36\" Float 2 AAAAAAAAAAA= \"Point37\" Float 2 AAAAAAAAAAA= \"Point38\" Float 2 AAAAAAAAAAA= \"Point39\" Float 2 AAAAAAAAAAA= \"Point40\" Float 2 AAAAAAAAAAA= \"Point41\" Float 2 AAAAAAAAAAA= \"Point42\" Float 2 AAAAAAAAAAA= \"Point43\" Float 2 AAAAAAAAAAA= \"Point44\" Float 2 AAAAAAAAAAA= \"Point45\" Float 2 AAAAAAAAAAA= \"Point46\" Float 2 AAAAAAAAAAA= \"Point47\" Float 2 AAAAAAAAAAA= \"Point48\" Float 2 AAAAAAAAAAA= \"Point49\" Float 2 AAAAAAAAAAA= 58 \"numControlPoints\" 1 1 Default \"numSamples\" 1 1 Default \"maxDistance\" 1 1 Default \"tightness\" 1 1 Default \"widthStart\" 1 1 Default \"widthCenter\" 1 1 Default \"widthEnd\" 1 1 Default \"normalizeSamples\" 1 1 Default \"Point0\" 2 1 Default \"Point1\" 2 1 Default \"Point2\" 2 1 Default \"Point3\" 2 1 Default \"Point4\" 2 1 Default \"Point5\" 2 1 Default \"Point6\" 2 1 Default \"Point7\" 2 1 Default \"Point8\" 2 1 Default \"Point9\" 2 1 Default \"Point10\" 2 1 Default \"Point11\" 2 1 Default \"Point12\" 2 1 Default \"Point13\" 2 1 Default \"Point14\" 2 1 Default \"Point15\" 2 1 Default \"Point16\" 2 1 Default \"Point17\" 2 1 Default \"Point18\" 2 1 Default \"Point19\" 2 1 Default \"Point20\" 2 1 Default \"Point21\" 2 1 Default \"Point22\" 2 1 Default \"Point23\" 2 1 Default \"Point24\" 2 1 Default \"Point25\" 2 1 Default \"Point26\" 2 1 Default \"Point27\" 2 1 Default \"Point28\" 2 1 Default \"Point29\" 2 1 Default \"Point30\" 2 1 Default \"Point31\" 2 1 Default \"Point32\" 2 1 Default \"Point33\" 2 1 Default \"Point34\" 2 1 Default \"Point35\" 2 1 Default \"Point36\" 2 1 Default \"Point37\" 2 1 Default \"Point38\" 2 1 Default \"Point39\" 2 1 Default \"Point40\" 2 1 Default \"Point41\" 2 1 Default \"Point42\" 2 1 Default \"Point43\" 2 1 Default \"Point44\" 2 1 Default \"Point45\" 2 1 Default \"Point46\" 2 1 Default \"Point47\" 2 1 Default \"Point48\" 2 1 Default \"Point49\" 2 1 Default 0"
  kernelSource "kernel SplineUVMap : ImageComputationKernel<ePixelWise>\n\{\n  Image<eWrite> dst;\n\n  param:\n    int numControlPoints;\n    int numSamples;\n    float maxDistance;\n    float tightness;\n    float widthStart;\n    float widthCenter;\n    float widthEnd;\n    bool normalizeSamples;\n\n    // Define control points up to the maximum allowed (50 points)\n    float2 Point0;\n    float2 Point1;\n    float2 Point2;\n    float2 Point3;\n    float2 Point4;\n    float2 Point5;\n    float2 Point6;\n    float2 Point7;\n    float2 Point8;\n    float2 Point9;\n    float2 Point10;\n    float2 Point11;\n    float2 Point12;\n    float2 Point13;\n    float2 Point14;\n    float2 Point15;\n    float2 Point16;\n    float2 Point17;\n    float2 Point18;\n    float2 Point19;\n    float2 Point20;\n    float2 Point21;\n    float2 Point22;\n    float2 Point23;\n    float2 Point24;\n    float2 Point25;\n    float2 Point26;\n    float2 Point27;\n    float2 Point28;\n    float2 Point29;\n    float2 Point30;\n    float2 Point31;\n    float2 Point32;\n    float2 Point33;\n    float2 Point34;\n    float2 Point35;\n    float2 Point36;\n    float2 Point37;\n    float2 Point38;\n    float2 Point39;\n    float2 Point40;\n    float2 Point41;\n    float2 Point42;\n    float2 Point43;\n    float2 Point44;\n    float2 Point45;\n    float2 Point46;\n    float2 Point47;\n    float2 Point48;\n    float2 Point49;\n\n  void define()\n  \{\n    defineParam(numControlPoints, \"Number of Control Points\", 4);\n    defineParam(numSamples, \"Number of Samples\", 100);\n    defineParam(maxDistance, \"Max Distance\", 50.0f);\n    defineParam(tightness, \"Curve Tightness\", 0.0f); // 0 = smooth, 1 = linear\n    defineParam(widthStart, \"Width Start\", 1.0f);\n    defineParam(widthCenter, \"Width Center\", 1.0f);\n    defineParam(widthEnd, \"Width End\", 1.0f);\n    defineParam(normalizeSamples, \"Normalize Samples\", false);\n\n    // Define each control point parameter\n    defineParam(Point0, \"Point0\", float2(0.0f, 0.0f));\n    defineParam(Point1, \"Point1\", float2(0.0f, 0.0f));\n    defineParam(Point2, \"Point2\", float2(0.0f, 0.0f));\n    defineParam(Point3, \"Point3\", float2(0.0f, 0.0f));\n    defineParam(Point4, \"Point4\", float2(0.0f, 0.0f));\n    defineParam(Point5, \"Point5\", float2(0.0f, 0.0f));\n    defineParam(Point6, \"Point6\", float2(0.0f, 0.0f));\n    defineParam(Point7, \"Point7\", float2(0.0f, 0.0f));\n    defineParam(Point8, \"Point8\", float2(0.0f, 0.0f));\n    defineParam(Point9, \"Point9\", float2(0.0f, 0.0f));\n    defineParam(Point10, \"Point10\", float2(0.0f, 0.0f));\n    defineParam(Point11, \"Point11\", float2(0.0f, 0.0f));\n    defineParam(Point12, \"Point12\", float2(0.0f, 0.0f));\n    defineParam(Point13, \"Point13\", float2(0.0f, 0.0f));\n    defineParam(Point14, \"Point14\", float2(0.0f, 0.0f));\n    defineParam(Point15, \"Point15\", float2(0.0f, 0.0f));\n    defineParam(Point16, \"Point16\", float2(0.0f, 0.0f));\n    defineParam(Point17, \"Point17\", float2(0.0f, 0.0f));\n    defineParam(Point18, \"Point18\", float2(0.0f, 0.0f));\n    defineParam(Point19, \"Point19\", float2(0.0f, 0.0f));\n    defineParam(Point20, \"Point20\", float2(0.0f, 0.0f));\n    defineParam(Point21, \"Point21\", float2(0.0f, 0.0f));\n    defineParam(Point22, \"Point22\", float2(0.0f, 0.0f));\n    defineParam(Point23, \"Point23\", float2(0.0f, 0.0f));\n    defineParam(Point24, \"Point24\", float2(0.0f, 0.0f));\n    defineParam(Point25, \"Point25\", float2(0.0f, 0.0f));\n    defineParam(Point26, \"Point26\", float2(0.0f, 0.0f));\n    defineParam(Point27, \"Point27\", float2(0.0f, 0.0f));\n    defineParam(Point28, \"Point28\", float2(0.0f, 0.0f));\n    defineParam(Point29, \"Point29\", float2(0.0f, 0.0f));\n    defineParam(Point30, \"Point30\", float2(0.0f, 0.0f));\n    defineParam(Point31, \"Point31\", float2(0.0f, 0.0f));\n    defineParam(Point32, \"Point32\", float2(0.0f, 0.0f));\n    defineParam(Point33, \"Point33\", float2(0.0f, 0.0f));\n    defineParam(Point34, \"Point34\", float2(0.0f, 0.0f));\n    defineParam(Point35, \"Point35\", float2(0.0f, 0.0f));\n    defineParam(Point36, \"Point36\", float2(0.0f, 0.0f));\n    defineParam(Point37, \"Point37\", float2(0.0f, 0.0f));\n    defineParam(Point38, \"Point38\", float2(0.0f, 0.0f));\n    defineParam(Point39, \"Point39\", float2(0.0f, 0.0f));\n    defineParam(Point40, \"Point40\", float2(0.0f, 0.0f));\n    defineParam(Point41, \"Point41\", float2(0.0f, 0.0f));\n    defineParam(Point42, \"Point42\", float2(0.0f, 0.0f));\n    defineParam(Point43, \"Point43\", float2(0.0f, 0.0f));\n    defineParam(Point44, \"Point44\", float2(0.0f, 0.0f));\n    defineParam(Point45, \"Point45\", float2(0.0f, 0.0f));\n    defineParam(Point46, \"Point46\", float2(0.0f, 0.0f));\n    defineParam(Point47, \"Point47\", float2(0.0f, 0.0f));\n    defineParam(Point48, \"Point48\", float2(0.0f, 0.0f));\n    defineParam(Point49, \"Point49\", float2(0.0f, 0.0f));\n  \}\n\n  float dot2(float2 a, float2 b) \{\n    return a.x * b.x + a.y * b.y;\n  \}\n\n  float length2(float2 v) \{\n    return sqrt(v.x * v.x + v.y * v.y);\n  \}\n\n  float2 normalize2(float2 v) \{\n    float len = length2(v);\n    if (len > 0.0f) \{\n      return float2(v.x / len, v.y / len);\n    \} else \{\n      return float2(0.0f, 0.0f);\n    \}\n  \}\n\n  float2 evaluateSpline(float t)\n  \{\n    int numSegments = numControlPoints - 1;\n    float totalLength = (float)(numSegments);\n    float scaledT = t * totalLength;\n    int segment = (int)(floor(scaledT));\n    if (segment >= numSegments)\n      segment = numSegments - 1;\n    float localT = scaledT - (float)(segment);\n\n    int p0 = max(segment - 1, 0);\n    int p1 = segment;\n    int p2 = min(segment + 1, numControlPoints - 1);\n    int p3 = min(segment + 2, numControlPoints - 1);\n\n    float2 CP\[50];\n    CP\[0] = Point0;\n    CP\[1] = Point1;\n    CP\[2] = Point2;\n    CP\[3] = Point3;\n    CP\[4] = Point4;\n    CP\[5] = Point5;\n    CP\[6] = Point6;\n    CP\[7] = Point7;\n    CP\[8] = Point8;\n    CP\[9] = Point9;\n    CP\[10] = Point10;\n    CP\[11] = Point11;\n    CP\[12] = Point12;\n    CP\[13] = Point13;\n    CP\[14] = Point14;\n    CP\[15] = Point15;\n    CP\[16] = Point16;\n    CP\[17] = Point17;\n    CP\[18] = Point18;\n    CP\[19] = Point19;\n    CP\[20] = Point20;\n    CP\[21] = Point21;\n    CP\[22] = Point22;\n    CP\[23] = Point23;\n    CP\[24] = Point24;\n    CP\[25] = Point25;\n    CP\[26] = Point26;\n    CP\[27] = Point27;\n    CP\[28] = Point28;\n    CP\[29] = Point29;\n    CP\[30] = Point30;\n    CP\[31] = Point31;\n    CP\[32] = Point32;\n    CP\[33] = Point33;\n    CP\[34] = Point34;\n    CP\[35] = Point35;\n    CP\[36] = Point36;\n    CP\[37] = Point37;\n    CP\[38] = Point38;\n    CP\[39] = Point39;\n    CP\[40] = Point40;\n    CP\[41] = Point41;\n    CP\[42] = Point42;\n    CP\[43] = Point43;\n    CP\[44] = Point44;\n    CP\[45] = Point45;\n    CP\[46] = Point46;\n    CP\[47] = Point47;\n    CP\[48] = Point48;\n    CP\[49] = Point49;\n\n    float2 P0 = CP\[p0];\n    float2 P1 = CP\[p1];\n    float2 P2 = CP\[p2];\n    float2 P3 = CP\[p3];\n\n    // Linear interpolation\n    float2 linear = P1 + (P2 - P1) * localT;\n\n    // Catmull-Rom spline interpolation\n    float2 catmullRom = 0.5f * (\n      (2.0f * P1) +\n      (-P0 + P2) * localT +\n      (2.0f * P0 - 5.0f * P1 + 4.0f * P2 - P3) * localT * localT +\n      (-P0 + 3.0f * P1 - 3.0f * P2 + P3) * localT * localT * localT\n    );\n\n    // Interpolate between linear and Catmull-Rom based on tightness\n    return linear * tightness + catmullRom * (1.0f - tightness);\n  \}\n\n  float2 tangentSpline(float t)\n  \{\n    int numSegments = numControlPoints - 1;\n    float totalLength = (float)(numSegments);\n    float scaledT = t * totalLength;\n    int segment = (int)(floor(scaledT));\n    if (segment >= numSegments)\n      segment = numSegments - 1;\n    float localT = scaledT - (float)(segment);\n\n    int p0 = max(segment - 1, 0);\n    int p1 = segment;\n    int p2 = min(segment + 1, numControlPoints - 1);\n    int p3 = min(segment + 2, numControlPoints - 1);\n\n    float2 CP\[50];\n    CP\[0] = Point0;\n    CP\[1] = Point1;\n    CP\[2] = Point2;\n    CP\[3] = Point3;\n    CP\[4] = Point4;\n    CP\[5] = Point5;\n    CP\[6] = Point6;\n    CP\[7] = Point7;\n    CP\[8] = Point8;\n    CP\[9] = Point9;\n    CP\[10] = Point10;\n    CP\[11] = Point11;\n    CP\[12] = Point12;\n    CP\[13] = Point13;\n    CP\[14] = Point14;\n    CP\[15] = Point15;\n    CP\[16] = Point16;\n    CP\[17] = Point17;\n    CP\[18] = Point18;\n    CP\[19] = Point19;\n    CP\[20] = Point20;\n    CP\[21] = Point21;\n    CP\[22] = Point22;\n    CP\[23] = Point23;\n    CP\[24] = Point24;\n    CP\[25] = Point25;\n    CP\[26] = Point26;\n    CP\[27] = Point27;\n    CP\[28] = Point28;\n    CP\[29] = Point29;\n    CP\[30] = Point30;\n    CP\[31] = Point31;\n    CP\[32] = Point32;\n    CP\[33] = Point33;\n    CP\[34] = Point34;\n    CP\[35] = Point35;\n    CP\[36] = Point36;\n    CP\[37] = Point37;\n    CP\[38] = Point38;\n    CP\[39] = Point39;\n    CP\[40] = Point40;\n    CP\[41] = Point41;\n    CP\[42] = Point42;\n    CP\[43] = Point43;\n    CP\[44] = Point44;\n    CP\[45] = Point45;\n    CP\[46] = Point46;\n    CP\[47] = Point47;\n    CP\[48] = Point48;\n    CP\[49] = Point49;\n\n    float2 P0 = CP\[p0];\n    float2 P1 = CP\[p1];\n    float2 P2 = CP\[p2];\n    float2 P3 = CP\[p3];\n\n    // Linear tangent\n    float2 linearTangent = P2 - P1;\n// Catmull-Rom tangent (continued)\n    float2 catmullRomTangent = 0.5f * (\n      (-P0 + P2) +\n      2.0f * (2.0f * P0 - 5.0f * P1 + 4.0f * P2 - P3) * localT +\n      3.0f * (-P0 + 3.0f * P1 - 3.0f * P2 + P3) * localT * localT\n    );\n\n    // Interpolate between linear and Catmull-Rom tangents based on tightness\n    return normalize2(linearTangent * tightness + catmullRomTangent * (1.0f - tightness));\n  \}\n\n  float getWidth(float t)\n  \{\n    if (t < 0.5f) \{\n      return widthStart + (widthCenter - widthStart) * (t * 2.0f);\n    \} else \{\n      return widthCenter + (widthEnd - widthCenter) * ((t - 0.5f) * 2.0f);\n    \}\n  \}\n\n  float normalizedSamplePosition(int sampleIndex)\n  \{\n    if (!normalizeSamples) \{\n      return (float)sampleIndex / (float)numSamples;\n    \}\n\n    float totalLength = 0.0f;\n    float segmentLengths\[50];\n    int numSegments = numControlPoints - 1;\n\n    for (int i = 0; i < numSegments; ++i) \{\n      float2 p1 = evaluateSpline((float)i / (float)numSegments);\n      float2 p2 = evaluateSpline((float)(i + 1) / (float)numSegments);\n      float segmentLength = length2(p2 - p1);\n      segmentLengths\[i] = segmentLength;\n      totalLength += segmentLength;\n    \}\n\n    float targetLength = totalLength * (float)sampleIndex / (float)numSamples;\n    float currentLength = 0.0f;\n\n    for (int i = 0; i < numSegments; ++i) \{\n      if (currentLength + segmentLengths\[i] >= targetLength) \{\n        float segmentT = (targetLength - currentLength) / segmentLengths\[i];\n        return ((float)i + segmentT) / (float)numSegments;\n      \}\n      currentLength += segmentLengths\[i];\n    \}\n\n    return 1.0f;\n  \}\n\n  void process(int2 pos)\n  \{\n    float2 pixelPos = float2((float)(pos.x), (float)(pos.y));\n\n    float minDistSq = 1e10f;\n    float closest_t = 0.0f;\n    float2 closestPoint = pixelPos;\n    float2 closestTangent = float2(0.0f, 0.0f);\n\n    for (int i = 0; i <= numSamples; ++i)\n    \{\n      float t = normalizedSamplePosition(i);\n\n      float2 S_t = evaluateSpline(t);\n      float2 tangent = tangentSpline(t);\n\n      float2 diff = pixelPos - S_t;\n      float distSq = dot2(diff, diff);\n\n      if (distSq < minDistSq)\n      \{\n        minDistSq = distSq;\n        closestPoint = S_t;\n        closestTangent = tangent;\n        closest_t = t;\n      \}\n    \}\n\n    float dist = sqrt(minDistSq);\n    float width = getWidth(closest_t);\n\n    if (dist <= maxDistance * width)\n    \{\n      float U = closest_t;\n\n      float2 normal = float2(-closestTangent.y, closestTangent.x);\n      normal = normalize2(normal);\n\n      float side = dot2(pixelPos - closestPoint, normal);\n      float V = side / (maxDistance * width) * 0.5f + 0.5f; // Normalize V to \[0,1]\n\n      dst() = float4(U, V, 0.0f, 1.0f);\n    \}\n    else\n    \{\n      dst() = float4(0.0f, 0.0f, 0.0f, 0.0f);\n    \}\n  \}\n\};"
  rebuild ""
  "SplineUVMap_Number of Control Points" 12
  "SplineUVMap_Number of Samples" 400
  "SplineUVMap_Max Distance" 55
  SplineUVMap_Point0 {83 590}
  SplineUVMap_Point1 {125 948}
  SplineUVMap_Point2 {375 1167}
  SplineUVMap_Point3 {648 1029}
  SplineUVMap_Point4 {690 633}
  SplineUVMap_Point5 {821 483}
  SplineUVMap_Point6 {964 448}
  SplineUVMap_Point7 {1056 660}
  SplineUVMap_Point8 {1180.301147 880.9065552}
  SplineUVMap_Point9 {1248 987}
  SplineUVMap_Point10 {1460 1087}
  SplineUVMap_Point11 {1791 1037}
  specifiedFormat true
  rebuild_finalise ""
  name BlinkScript
  selected true
  xpos 656
  ypos 25
 }
 Dot {
  name Dot_FW
  label "this dot is used to locate the Blinkscript"
  note_font_size 10
  xpos 690
  ypos 84
 }
set Na465d000 [stack 0]
 Dot {
  name Dot10
  xpos 846
  ypos 147
 }
 FilterErode {
  size 0
  filter gaussian
  name FilterErode1
  xpos 812
  ypos 258
 }
push $Na465d000
 Blur {
  size {{parent.UVBLUR}}
  name Blur1
  xpos 656
  ypos 122
 }
 Input {
  inputs 0
  name Image
  xpos 455
  ypos 168
  number 1
 }
 STMap {
  inputs 2
  uv rgb
  name STMap2
  xpos 656
  ypos 207
 }
 Merge2 {
  inputs 2
  operation mask
  name Merge1
  xpos 656
  ypos 264
 }
 Output {
  name Output1
  xpos 656
  ypos 308
 }
 Input {
  inputs 0
  name Roto
  xpos 987
  ypos 199
 }
end_group
FrameHold {
 firstFrame 29
 name FrameHold2
 xpos 2062
 ypos 1302
}
Dot {
 name Dot1
 tile_color 0x84b9f2ff
 label "View Me"
 note_font_size 77
 xpos 2096
 ypos 1388
}
StickyNote {
 inputs 0
 name StickyNote12
 tile_color 0xc85accff
 label 1.
 note_font_size 77
 xpos -147
 ypos -679
}
StickyNote {
 inputs 0
 name StickyNote13
 tile_color 0xc85accff
 label 2.
 note_font_size 77
 xpos -242
 ypos 104
}
StickyNote {
 inputs 0
 name StickyNote14
 tile_color 0xc85accff
 label 3.
 note_font_size 77
 xpos 1315
 ypos -54
}
StickyNote {
 inputs 0
 name StickyNote5
 label B.
 note_font_size 66
 xpos 2445
 ypos 67
}
StickyNote {
 inputs 0
 name StickyNote8
 tile_color 0x666dccff
 label "Slower Computationally, Higher Quality"
 note_font_size 15
 xpos 2361
 ypos 208
}
StickyNote {
 inputs 0
 name StickyNote6
 tile_color 0xbe8bccff
 label "(in other words.... just make your image format wider with \"resize type\" set to none.)"
 note_font_size 15
 xpos 2216
 ypos 180
}
StickyNote {
 inputs 0
 name StickyNote9
 tile_color 0x3549ccff
 label "     ADD MORE POINTS TO YOUR ROTO SPLINE, AND RESAMPLE (Check below)    \n\n"
 note_font "Verdana Bold"
 note_font_size 21
 xpos 1861
 ypos 850
}
StickyNote {
 inputs 0
 name StickyNote3
 label "how to maintain proportions of a shape"
 note_font_size 66
 xpos 1417
 ypos -40
}
StickyNote {
 inputs 0
 name StickyNote15
 tile_color 0x4649ccff
 label www.compositingacademy.com
 note_font_size 66
 xpos 1089
 ypos -1494
}
StickyNote {
 inputs 0
 name StickyNote16
 tile_color 0xcc6ab2ff
 label "Compositing Training + Tools + Stock Footage."
 note_font_size 66
 xpos 844
 ypos -1387
}
StickyNote {
 inputs 0
 name StickyNote21
 tile_color 0x48aeccff
 label "       https://www.compositingacademy.com/energyfx      "
 note_font_size 33
 xpos 4260
 ypos -19
}
StickyNote {
 inputs 0
 name StickyNote22
 tile_color 0x83cc7cff
 label "(Individual or Studio Licenses Available)"
 note_font_size 33
 xpos 4452
 ypos -65
}
StickyNote {
 inputs 0
 name StickyNote18
 tile_color 0xcc6ab2ff
 label "Laser Beam Example"
 note_font_size 66
 xpos 4434
 ypos -220
}
StickyNote {
 inputs 0
 name StickyNote17
 tile_color 0x7fcca8ff
 label "           If this tool helps you, share our link!  Compositing Academy only exists        \nwith your support!"
 note_font_size 44
 xpos 758
 ypos -1282
}
StickyNote {
 inputs 0
 name StickyNote24
 tile_color 0x7fcca8ff
 label "This tool was made and tested on an RTX 3090.  GPU performance\ndepends on your GFX card.\n"
 note_font_size 44
 xpos 871
 ypos -1094
}
StickyNote {
 inputs 0
 name StickyNote23
 tile_color 0x58cc8eff
 label "\n\nPlaying with the \"TAPER CONTROLS\"\ncan really help to get good results.\n\nPlaying with \"UV blur\" can smooth\nout curves or low samples.\n\nIf you use a lot of \"UV BLUR\"\nyou can use \"Erode Edge\" to clean\nup sharp edges."
 note_font_size 15
 xpos 4639
 ypos 960
}
StickyNote {
 inputs 0
 name StickyNote10
 label "basic example"
 note_font_size 66
 xpos -142
 ypos 111
}
StickyNote {
 inputs 0
 name StickyNote20
 tile_color 0x83cc7cff
 label "          Get the largest LookDev FX Library on the internet here:      "
 note_font_size 33
 xpos 4185
 ypos -109
}
ColorWheel {
 inputs 0
 gamma 0.45
 name ColorWheel9
 xpos 294
 ypos -532
}
Group {
 name Offset3
 xpos 294
 ypos -378
 addUserKnob {20 User l Offset}
 addUserKnob {12 offset}
 addUserKnob {14 tiles R 0 100}
 tiles 1
 addUserKnob {6 mx l "mirror x" +STARTLINE}
 addUserKnob {6 my l "mirror y" -STARTLINE}
 addUserKnob {41 filter T STMap1.filter}
 addUserKnob {26 ""}
 addUserKnob {41 motionblur T mb_trans.motionblur}
 addUserKnob {41 shutter T mb_trans.shutter}
 addUserKnob {41 shutteroffset l "shutter offset" T mb_trans.shutteroffset}
 addUserKnob {41 shuttercustomoffset l "" -STARTLINE T mb_trans.shuttercustomoffset}
 addUserKnob {20 about l @}
 addUserKnob {26 author l "Author: " T "Mariusz Wesierski ( mw@fxcalibur.com )"}
 addUserKnob {26 version l "Version: " T 1.0}
}
 Input {
  inputs 0
  name Input1
  xpos -301
  ypos -196
 }
set Nac38c400 [stack 0]
 Expression {
  expr0 ((x-offset.x)<0?1+((x-offset.x)/width*tiles.w)-int((x-offset.x)/width*tiles.w):((x-offset.x)/width*tiles.w)-int((x-offset.x)/width*tiles.w))
  expr1 ((y-offset.y)<0?1+((y-offset.y)/height*tiles.h)-int((y-offset.y)/height*tiles.h):((y-offset.y)/height*tiles.h)-int((y-offset.y)/height*tiles.h))
  expr2 0
  channel3 {none none none -rgba.alpha}
  name offset_xp
  xpos -422
  ypos -142
 }
 Expression {
  expr0 "mx?(x-offset.x>=0?0:1)+ fmod(int((x-offset.x)/width*tiles.w),2)!=0?1-r:r:r"
  expr1 "my?(y-offset.y>=0?0:1)+ fmod(int((y-offset.y)/height*tiles.h),2)!=0?1-g:g:g"
  channel2 {-rgba.red -rgba.green -rgba.blue none}
  channel3 none
  name mirror_xp
  xpos -422
  ypos -118
  disable {{mx?0:my?0:1}}
 }
push $Nac38c400
 STMap {
  inputs 2
  uv rgb
  blur_scale 0
  filter impulse
  name STMap1
  xpos -301
  ypos -124
 }
 Transform {
  translate {{offset.x i} {offset.y i}}
  center {800 501.5}
  filter impulse
  shutteroffset centred
  name mb_trans
  xpos -301
  ypos -81
  disable {{motionblur>0?0:1 i}}
 }
 Transform {
  translate {{-offset.x i} {-offset.y i}}
  center {800 501.5}
  filter impulse
  black_outside false
  name inv_trans
  xpos -301
  ypos -57
  disable {{mb_trans.motionblur>0?0:1 i}}
 }
 Output {
  name Output1
  xpos -301
  ypos -23
 }
end_group
Roto {
 inputs 0
 output alpha
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097664}
    {t x44800000 x44428000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup OpenSpline1 1049088 bezier
     {{cc
       {f 1056800}
       {px x42680000
        {xc1000000 xc2d80000}
        {{a osw
       {{x42680000 1}}	 osf
       {{x42680000 0}}}     x439c0000 x44178000}
        {x41000000 x42d80000}
        {xc2100000 xc2000000}
        {{a osw
       {{x42680000 1}}	 osf
       {{x42680000 0}}}     x43f20000 x448dc000}
        {x42100000 x42000000}
        {0 x42500000}
        {{a osw
       {{x42680000 1}}	 osf
       {{x42680000 0}}}     x44520000 x44638000}
        {0 xc2500000}
        {xc2980000 x42600000}
        {{a osw
       {{x42680000 1}}	 osf
       {{x42680000 0}}}     x447c0000 x44008000}
        {x42980000 xc2600000}
        {xc1800000 xc2600000}
        {{a osw
       {{x42680000 1}}	 osf
       {{x42680000 0}}}     x44b68000 x44208000}
        {x41800000 x42600000}
        {0 0}
        {{a osw
       {{x42680000 1}}	 osf
       {{x42680000 0}}}     x44c10000 x446d8000}
        {0 0}}}     idem}
     {tx x42680000 x446b5555 x44462aab}
     {a osbe 0 osee 0 osw x41200000 osf 0 str 1 ltn x42680000 ltm x42680000 tt x41200000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createOpenSpline str 1 ssx 1 ssy 1 sf 1 tt 10 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {320 240}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 lifetime_start 58
 lifetime_end 58
 motionblur_shutter_offset_type centred
 name Roto5
 xpos -131
 ypos -525
}
Group {
 inputs 2
 name CA_FlowWarp6
 tile_color 0x4c65ffff
 note_font "Verdana Bold"
 note_font_size 12
 note_font_color 0xe0cc30ff
 xpos -131
 ypos -380
 addUserKnob {20 User}
 addUserKnob {41 format T BlinkScript.format}
 addUserKnob {26 d l " " T "Make sure format matches roto"}
 addUserKnob {26 ""}
 addUserKnob {22 SampleRoto l "Sample Roto" T "import nuke\nimport nuke.rotopaint as rp\n\n# Function to retrieve points from the Roto node's shapes and strokes\ndef get_roto_points(roto_node):\n    curves_knob = roto_node\['curves']\n    points = \[]\n    processed_elements = set()  # To track processed elements\n\n    # Access the root layer of the Roto node\n    root_layer = curves_knob.rootLayer\n\n    # Function to parse the layer and find shapes and strokes\n    def parse_layer(layer):\n        for element in layer:\n            element_id = id(element)  # Unique identifier for each element\n\n            # Check if the element is a Shape and not already processed\n            if isinstance(element, rp.Shape) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark element as processed\n\n                # Loop through the control points (CVs) in the shape\n                for point_idx, point in enumerate(element):\n                    frame = nuke.frame()\n                    # Get the position of the control vertex (center point)\n                    pos = point.center.getPosition(frame)\n                    points.append((pos\[0], pos\[1]))\n\n            # If the element is a Layer, process its contents\n            elif isinstance(element, rp.Layer) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark layer as processed\n                parse_layer(element)  # Recursively parse nested layers\n\n    # Parse the root layer to extract points\n    parse_layer(root_layer)\n    \n    return points\n\n# Main function to run the script and update the BlinkScript node\ndef main():\n    # Get the current node (the group node)\n    current_node = nuke.thisNode()\n\n    # Check if there is an input connected to the node (assuming input 0 is the roto node)\n    roto_node = current_node.input(0)\n    \n    if not roto_node or roto_node.Class() not in \['Roto', 'RotoPaint']:\n        nuke.message(\"Please connect a Roto or RotoPaint node to the current node.\")\n        return\n\n    # Get the points from the connected Roto or RotoPaint node\n    roto_points = get_roto_points(roto_node)\n    \n    if not roto_points:\n        nuke.message(\"No points found in the connected Roto node.\")\n        return\n    else:\n        # Begin the group to access internal nodes\n        current_node.begin()\n        # Find the BlinkScript node inside the group\n        blinkscript_node = None\n        blinkscript_node = nuke.toNode(current_node.name()+\".Dot_FW\").input(0)\n        \n        if blinkscript_node is None:\n            nuke.message(\"BlinkScript node not found inside the group.\")\n            current_node.end()\n            return\n\n        # Update the BlinkScript node parameters\n        # Set \"Number of Control Points\" to the number of points retrieved\n        blinkscript_node\['SplineUVMap_Number of Control Points'].setValue(len(roto_points))\n        # Update the positions of the points\n        max_points = 50  # Updated to support up to 50 points\n        for idx, point in enumerate(roto_points):\n            if idx >= max_points:\n                nuke.warning(f\"BlinkScript node supports a maximum of \{max_points\} points. Extra points are ignored.\")\n                break\n            # The point knobs are named \"SplineUVMap_Point0\", \"SplineUVMap_Point1\", etc.\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue(point)\n            else:\n                nuke.warning(f\"BlinkScript node does not have knob \{knob_name\}\")\n\n        # For any remaining Point knobs, set them to (0, 0)\n        for idx in range(len(roto_points), max_points):\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue((0.0, 0.0))\n\n        # End the group\n        current_node.end()\n\n# Execute the main function\nmain()" +STARTLINE}
 addUserKnob {41 "SplineUVMap_Number of Samples_1" l "Number of Samples" T "BlinkScript.SplineUVMap_Number of Samples"}
 addUserKnob {41 "SplineUVMap_Max Distance" l "Max Distance" T "BlinkScript.SplineUVMap_Max Distance"}
 addUserKnob {7 UVBLUR l "UV Blur" R 0 50}
 addUserKnob {41 "SplineUVMap_Curve Tightness" l "Curve Tightness" T "BlinkScript.SplineUVMap_Curve Tightness"}
 addUserKnob {41 "SplineUVMap_Normalize Samples" l "Normalize Samples" T "BlinkScript.SplineUVMap_Normalize Samples"}
 addUserKnob {26 explanation l Samples T "If you want your\nsamples evenly spread,\nnormalize them"}
 addUserKnob {26 ""}
 addUserKnob {41 "SplineUVMap_Number of Control Points" l "Number of Control Points" T "BlinkScript.SplineUVMap_Number of Control Points"}
 addUserKnob {26 _1 l Info: T "Auto detected from Sample Roto.  \nYou can put custom control points\nin group if you want."}
 addUserKnob {26 ""}
 addUserKnob {26 tapers l " " T "Taper Controls"}
 addUserKnob {41 "SplineUVMap_Width Start" l "Width Start" T "BlinkScript.SplineUVMap_Width Start"}
 addUserKnob {41 "SplineUVMap_Width Center" l "Width Center" T "BlinkScript.SplineUVMap_Width Center"}
 addUserKnob {41 "SplineUVMap_Width End" l "Width End" T "BlinkScript.SplineUVMap_Width End"}
 addUserKnob {26 ""}
 addUserKnob {26 Edge l "" -STARTLINE T "Edge Details"}
 addUserKnob {41 size l "Erode Edge" T FilterErode1.size}
 addUserKnob {41 filter l "Edge Filter" T FilterErode1.filter}
 addUserKnob {26 ""}
 addUserKnob {26 compacademy l " " T "For more:\nTools, Training, Epic Stock Footage:\n\nwww.compositingacademy.com\n\nMade in 2024"}
}
 BlinkScript {
  inputs 0
  recompileCount 2
  ProgramGroup 1
  KernelDescription "3 \"SplineUVMap\" iterate pixelWise 7323e521568e7c81daf69ed13b674e934e88cc6f9c6cb7a338b61e69790b719a 1 \"dst\" Write Point 58 \"Number of Control Points\" Int 1 BAAAAA== \"Number of Samples\" Int 1 ZAAAAA== \"Max Distance\" Float 1 AABIQg== \"Curve Tightness\" Float 1 AAAAAA== \"Width Start\" Float 1 AACAPw== \"Width Center\" Float 1 AACAPw== \"Width End\" Float 1 AACAPw== \"Normalize Samples\" Bool 1 AA== \"Point0\" Float 2 AAAAAAAAAAA= \"Point1\" Float 2 AAAAAAAAAAA= \"Point2\" Float 2 AAAAAAAAAAA= \"Point3\" Float 2 AAAAAAAAAAA= \"Point4\" Float 2 AAAAAAAAAAA= \"Point5\" Float 2 AAAAAAAAAAA= \"Point6\" Float 2 AAAAAAAAAAA= \"Point7\" Float 2 AAAAAAAAAAA= \"Point8\" Float 2 AAAAAAAAAAA= \"Point9\" Float 2 AAAAAAAAAAA= \"Point10\" Float 2 AAAAAAAAAAA= \"Point11\" Float 2 AAAAAAAAAAA= \"Point12\" Float 2 AAAAAAAAAAA= \"Point13\" Float 2 AAAAAAAAAAA= \"Point14\" Float 2 AAAAAAAAAAA= \"Point15\" Float 2 AAAAAAAAAAA= \"Point16\" Float 2 AAAAAAAAAAA= \"Point17\" Float 2 AAAAAAAAAAA= \"Point18\" Float 2 AAAAAAAAAAA= \"Point19\" Float 2 AAAAAAAAAAA= \"Point20\" Float 2 AAAAAAAAAAA= \"Point21\" Float 2 AAAAAAAAAAA= \"Point22\" Float 2 AAAAAAAAAAA= \"Point23\" Float 2 AAAAAAAAAAA= \"Point24\" Float 2 AAAAAAAAAAA= \"Point25\" Float 2 AAAAAAAAAAA= \"Point26\" Float 2 AAAAAAAAAAA= \"Point27\" Float 2 AAAAAAAAAAA= \"Point28\" Float 2 AAAAAAAAAAA= \"Point29\" Float 2 AAAAAAAAAAA= \"Point30\" Float 2 AAAAAAAAAAA= \"Point31\" Float 2 AAAAAAAAAAA= \"Point32\" Float 2 AAAAAAAAAAA= \"Point33\" Float 2 AAAAAAAAAAA= \"Point34\" Float 2 AAAAAAAAAAA= \"Point35\" Float 2 AAAAAAAAAAA= \"Point36\" Float 2 AAAAAAAAAAA= \"Point37\" Float 2 AAAAAAAAAAA= \"Point38\" Float 2 AAAAAAAAAAA= \"Point39\" Float 2 AAAAAAAAAAA= \"Point40\" Float 2 AAAAAAAAAAA= \"Point41\" Float 2 AAAAAAAAAAA= \"Point42\" Float 2 AAAAAAAAAAA= \"Point43\" Float 2 AAAAAAAAAAA= \"Point44\" Float 2 AAAAAAAAAAA= \"Point45\" Float 2 AAAAAAAAAAA= \"Point46\" Float 2 AAAAAAAAAAA= \"Point47\" Float 2 AAAAAAAAAAA= \"Point48\" Float 2 AAAAAAAAAAA= \"Point49\" Float 2 AAAAAAAAAAA= 58 \"numControlPoints\" 1 1 Default \"numSamples\" 1 1 Default \"maxDistance\" 1 1 Default \"tightness\" 1 1 Default \"widthStart\" 1 1 Default \"widthCenter\" 1 1 Default \"widthEnd\" 1 1 Default \"normalizeSamples\" 1 1 Default \"Point0\" 2 1 Default \"Point1\" 2 1 Default \"Point2\" 2 1 Default \"Point3\" 2 1 Default \"Point4\" 2 1 Default \"Point5\" 2 1 Default \"Point6\" 2 1 Default \"Point7\" 2 1 Default \"Point8\" 2 1 Default \"Point9\" 2 1 Default \"Point10\" 2 1 Default \"Point11\" 2 1 Default \"Point12\" 2 1 Default \"Point13\" 2 1 Default \"Point14\" 2 1 Default \"Point15\" 2 1 Default \"Point16\" 2 1 Default \"Point17\" 2 1 Default \"Point18\" 2 1 Default \"Point19\" 2 1 Default \"Point20\" 2 1 Default \"Point21\" 2 1 Default \"Point22\" 2 1 Default \"Point23\" 2 1 Default \"Point24\" 2 1 Default \"Point25\" 2 1 Default \"Point26\" 2 1 Default \"Point27\" 2 1 Default \"Point28\" 2 1 Default \"Point29\" 2 1 Default \"Point30\" 2 1 Default \"Point31\" 2 1 Default \"Point32\" 2 1 Default \"Point33\" 2 1 Default \"Point34\" 2 1 Default \"Point35\" 2 1 Default \"Point36\" 2 1 Default \"Point37\" 2 1 Default \"Point38\" 2 1 Default \"Point39\" 2 1 Default \"Point40\" 2 1 Default \"Point41\" 2 1 Default \"Point42\" 2 1 Default \"Point43\" 2 1 Default \"Point44\" 2 1 Default \"Point45\" 2 1 Default \"Point46\" 2 1 Default \"Point47\" 2 1 Default \"Point48\" 2 1 Default \"Point49\" 2 1 Default 0"
  kernelSource "kernel SplineUVMap : ImageComputationKernel<ePixelWise>\n\{\n  Image<eWrite> dst;\n\n  param:\n    int numControlPoints;\n    int numSamples;\n    float maxDistance;\n    float tightness;\n    float widthStart;\n    float widthCenter;\n    float widthEnd;\n    bool normalizeSamples;\n\n    // Define control points up to the maximum allowed (50 points)\n    float2 Point0;\n    float2 Point1;\n    float2 Point2;\n    float2 Point3;\n    float2 Point4;\n    float2 Point5;\n    float2 Point6;\n    float2 Point7;\n    float2 Point8;\n    float2 Point9;\n    float2 Point10;\n    float2 Point11;\n    float2 Point12;\n    float2 Point13;\n    float2 Point14;\n    float2 Point15;\n    float2 Point16;\n    float2 Point17;\n    float2 Point18;\n    float2 Point19;\n    float2 Point20;\n    float2 Point21;\n    float2 Point22;\n    float2 Point23;\n    float2 Point24;\n    float2 Point25;\n    float2 Point26;\n    float2 Point27;\n    float2 Point28;\n    float2 Point29;\n    float2 Point30;\n    float2 Point31;\n    float2 Point32;\n    float2 Point33;\n    float2 Point34;\n    float2 Point35;\n    float2 Point36;\n    float2 Point37;\n    float2 Point38;\n    float2 Point39;\n    float2 Point40;\n    float2 Point41;\n    float2 Point42;\n    float2 Point43;\n    float2 Point44;\n    float2 Point45;\n    float2 Point46;\n    float2 Point47;\n    float2 Point48;\n    float2 Point49;\n\n  void define()\n  \{\n    defineParam(numControlPoints, \"Number of Control Points\", 4);\n    defineParam(numSamples, \"Number of Samples\", 100);\n    defineParam(maxDistance, \"Max Distance\", 50.0f);\n    defineParam(tightness, \"Curve Tightness\", 0.0f); // 0 = smooth, 1 = linear\n    defineParam(widthStart, \"Width Start\", 1.0f);\n    defineParam(widthCenter, \"Width Center\", 1.0f);\n    defineParam(widthEnd, \"Width End\", 1.0f);\n    defineParam(normalizeSamples, \"Normalize Samples\", false);\n\n    // Define each control point parameter\n    defineParam(Point0, \"Point0\", float2(0.0f, 0.0f));\n    defineParam(Point1, \"Point1\", float2(0.0f, 0.0f));\n    defineParam(Point2, \"Point2\", float2(0.0f, 0.0f));\n    defineParam(Point3, \"Point3\", float2(0.0f, 0.0f));\n    defineParam(Point4, \"Point4\", float2(0.0f, 0.0f));\n    defineParam(Point5, \"Point5\", float2(0.0f, 0.0f));\n    defineParam(Point6, \"Point6\", float2(0.0f, 0.0f));\n    defineParam(Point7, \"Point7\", float2(0.0f, 0.0f));\n    defineParam(Point8, \"Point8\", float2(0.0f, 0.0f));\n    defineParam(Point9, \"Point9\", float2(0.0f, 0.0f));\n    defineParam(Point10, \"Point10\", float2(0.0f, 0.0f));\n    defineParam(Point11, \"Point11\", float2(0.0f, 0.0f));\n    defineParam(Point12, \"Point12\", float2(0.0f, 0.0f));\n    defineParam(Point13, \"Point13\", float2(0.0f, 0.0f));\n    defineParam(Point14, \"Point14\", float2(0.0f, 0.0f));\n    defineParam(Point15, \"Point15\", float2(0.0f, 0.0f));\n    defineParam(Point16, \"Point16\", float2(0.0f, 0.0f));\n    defineParam(Point17, \"Point17\", float2(0.0f, 0.0f));\n    defineParam(Point18, \"Point18\", float2(0.0f, 0.0f));\n    defineParam(Point19, \"Point19\", float2(0.0f, 0.0f));\n    defineParam(Point20, \"Point20\", float2(0.0f, 0.0f));\n    defineParam(Point21, \"Point21\", float2(0.0f, 0.0f));\n    defineParam(Point22, \"Point22\", float2(0.0f, 0.0f));\n    defineParam(Point23, \"Point23\", float2(0.0f, 0.0f));\n    defineParam(Point24, \"Point24\", float2(0.0f, 0.0f));\n    defineParam(Point25, \"Point25\", float2(0.0f, 0.0f));\n    defineParam(Point26, \"Point26\", float2(0.0f, 0.0f));\n    defineParam(Point27, \"Point27\", float2(0.0f, 0.0f));\n    defineParam(Point28, \"Point28\", float2(0.0f, 0.0f));\n    defineParam(Point29, \"Point29\", float2(0.0f, 0.0f));\n    defineParam(Point30, \"Point30\", float2(0.0f, 0.0f));\n    defineParam(Point31, \"Point31\", float2(0.0f, 0.0f));\n    defineParam(Point32, \"Point32\", float2(0.0f, 0.0f));\n    defineParam(Point33, \"Point33\", float2(0.0f, 0.0f));\n    defineParam(Point34, \"Point34\", float2(0.0f, 0.0f));\n    defineParam(Point35, \"Point35\", float2(0.0f, 0.0f));\n    defineParam(Point36, \"Point36\", float2(0.0f, 0.0f));\n    defineParam(Point37, \"Point37\", float2(0.0f, 0.0f));\n    defineParam(Point38, \"Point38\", float2(0.0f, 0.0f));\n    defineParam(Point39, \"Point39\", float2(0.0f, 0.0f));\n    defineParam(Point40, \"Point40\", float2(0.0f, 0.0f));\n    defineParam(Point41, \"Point41\", float2(0.0f, 0.0f));\n    defineParam(Point42, \"Point42\", float2(0.0f, 0.0f));\n    defineParam(Point43, \"Point43\", float2(0.0f, 0.0f));\n    defineParam(Point44, \"Point44\", float2(0.0f, 0.0f));\n    defineParam(Point45, \"Point45\", float2(0.0f, 0.0f));\n    defineParam(Point46, \"Point46\", float2(0.0f, 0.0f));\n    defineParam(Point47, \"Point47\", float2(0.0f, 0.0f));\n    defineParam(Point48, \"Point48\", float2(0.0f, 0.0f));\n    defineParam(Point49, \"Point49\", float2(0.0f, 0.0f));\n  \}\n\n  float dot2(float2 a, float2 b) \{\n    return a.x * b.x + a.y * b.y;\n  \}\n\n  float length2(float2 v) \{\n    return sqrt(v.x * v.x + v.y * v.y);\n  \}\n\n  float2 normalize2(float2 v) \{\n    float len = length2(v);\n    if (len > 0.0f) \{\n      return float2(v.x / len, v.y / len);\n    \} else \{\n      return float2(0.0f, 0.0f);\n    \}\n  \}\n\n  float2 evaluateSpline(float t)\n  \{\n    int numSegments = numControlPoints - 1;\n    float totalLength = (float)(numSegments);\n    float scaledT = t * totalLength;\n    int segment = (int)(floor(scaledT));\n    if (segment >= numSegments)\n      segment = numSegments - 1;\n    float localT = scaledT - (float)(segment);\n\n    int p0 = max(segment - 1, 0);\n    int p1 = segment;\n    int p2 = min(segment + 1, numControlPoints - 1);\n    int p3 = min(segment + 2, numControlPoints - 1);\n\n    float2 CP\[50];\n    CP\[0] = Point0;\n    CP\[1] = Point1;\n    CP\[2] = Point2;\n    CP\[3] = Point3;\n    CP\[4] = Point4;\n    CP\[5] = Point5;\n    CP\[6] = Point6;\n    CP\[7] = Point7;\n    CP\[8] = Point8;\n    CP\[9] = Point9;\n    CP\[10] = Point10;\n    CP\[11] = Point11;\n    CP\[12] = Point12;\n    CP\[13] = Point13;\n    CP\[14] = Point14;\n    CP\[15] = Point15;\n    CP\[16] = Point16;\n    CP\[17] = Point17;\n    CP\[18] = Point18;\n    CP\[19] = Point19;\n    CP\[20] = Point20;\n    CP\[21] = Point21;\n    CP\[22] = Point22;\n    CP\[23] = Point23;\n    CP\[24] = Point24;\n    CP\[25] = Point25;\n    CP\[26] = Point26;\n    CP\[27] = Point27;\n    CP\[28] = Point28;\n    CP\[29] = Point29;\n    CP\[30] = Point30;\n    CP\[31] = Point31;\n    CP\[32] = Point32;\n    CP\[33] = Point33;\n    CP\[34] = Point34;\n    CP\[35] = Point35;\n    CP\[36] = Point36;\n    CP\[37] = Point37;\n    CP\[38] = Point38;\n    CP\[39] = Point39;\n    CP\[40] = Point40;\n    CP\[41] = Point41;\n    CP\[42] = Point42;\n    CP\[43] = Point43;\n    CP\[44] = Point44;\n    CP\[45] = Point45;\n    CP\[46] = Point46;\n    CP\[47] = Point47;\n    CP\[48] = Point48;\n    CP\[49] = Point49;\n\n    float2 P0 = CP\[p0];\n    float2 P1 = CP\[p1];\n    float2 P2 = CP\[p2];\n    float2 P3 = CP\[p3];\n\n    // Linear interpolation\n    float2 linear = P1 + (P2 - P1) * localT;\n\n    // Catmull-Rom spline interpolation\n    float2 catmullRom = 0.5f * (\n      (2.0f * P1) +\n      (-P0 + P2) * localT +\n      (2.0f * P0 - 5.0f * P1 + 4.0f * P2 - P3) * localT * localT +\n      (-P0 + 3.0f * P1 - 3.0f * P2 + P3) * localT * localT * localT\n    );\n\n    // Interpolate between linear and Catmull-Rom based on tightness\n    return linear * tightness + catmullRom * (1.0f - tightness);\n  \}\n\n  float2 tangentSpline(float t)\n  \{\n    int numSegments = numControlPoints - 1;\n    float totalLength = (float)(numSegments);\n    float scaledT = t * totalLength;\n    int segment = (int)(floor(scaledT));\n    if (segment >= numSegments)\n      segment = numSegments - 1;\n    float localT = scaledT - (float)(segment);\n\n    int p0 = max(segment - 1, 0);\n    int p1 = segment;\n    int p2 = min(segment + 1, numControlPoints - 1);\n    int p3 = min(segment + 2, numControlPoints - 1);\n\n    float2 CP\[50];\n    CP\[0] = Point0;\n    CP\[1] = Point1;\n    CP\[2] = Point2;\n    CP\[3] = Point3;\n    CP\[4] = Point4;\n    CP\[5] = Point5;\n    CP\[6] = Point6;\n    CP\[7] = Point7;\n    CP\[8] = Point8;\n    CP\[9] = Point9;\n    CP\[10] = Point10;\n    CP\[11] = Point11;\n    CP\[12] = Point12;\n    CP\[13] = Point13;\n    CP\[14] = Point14;\n    CP\[15] = Point15;\n    CP\[16] = Point16;\n    CP\[17] = Point17;\n    CP\[18] = Point18;\n    CP\[19] = Point19;\n    CP\[20] = Point20;\n    CP\[21] = Point21;\n    CP\[22] = Point22;\n    CP\[23] = Point23;\n    CP\[24] = Point24;\n    CP\[25] = Point25;\n    CP\[26] = Point26;\n    CP\[27] = Point27;\n    CP\[28] = Point28;\n    CP\[29] = Point29;\n    CP\[30] = Point30;\n    CP\[31] = Point31;\n    CP\[32] = Point32;\n    CP\[33] = Point33;\n    CP\[34] = Point34;\n    CP\[35] = Point35;\n    CP\[36] = Point36;\n    CP\[37] = Point37;\n    CP\[38] = Point38;\n    CP\[39] = Point39;\n    CP\[40] = Point40;\n    CP\[41] = Point41;\n    CP\[42] = Point42;\n    CP\[43] = Point43;\n    CP\[44] = Point44;\n    CP\[45] = Point45;\n    CP\[46] = Point46;\n    CP\[47] = Point47;\n    CP\[48] = Point48;\n    CP\[49] = Point49;\n\n    float2 P0 = CP\[p0];\n    float2 P1 = CP\[p1];\n    float2 P2 = CP\[p2];\n    float2 P3 = CP\[p3];\n\n    // Linear tangent\n    float2 linearTangent = P2 - P1;\n// Catmull-Rom tangent (continued)\n    float2 catmullRomTangent = 0.5f * (\n      (-P0 + P2) +\n      2.0f * (2.0f * P0 - 5.0f * P1 + 4.0f * P2 - P3) * localT +\n      3.0f * (-P0 + 3.0f * P1 - 3.0f * P2 + P3) * localT * localT\n    );\n\n    // Interpolate between linear and Catmull-Rom tangents based on tightness\n    return normalize2(linearTangent * tightness + catmullRomTangent * (1.0f - tightness));\n  \}\n\n  float getWidth(float t)\n  \{\n    if (t < 0.5f) \{\n      return widthStart + (widthCenter - widthStart) * (t * 2.0f);\n    \} else \{\n      return widthCenter + (widthEnd - widthCenter) * ((t - 0.5f) * 2.0f);\n    \}\n  \}\n\n  float normalizedSamplePosition(int sampleIndex)\n  \{\n    if (!normalizeSamples) \{\n      return (float)sampleIndex / (float)numSamples;\n    \}\n\n    float totalLength = 0.0f;\n    float segmentLengths\[50];\n    int numSegments = numControlPoints - 1;\n\n    for (int i = 0; i < numSegments; ++i) \{\n      float2 p1 = evaluateSpline((float)i / (float)numSegments);\n      float2 p2 = evaluateSpline((float)(i + 1) / (float)numSegments);\n      float segmentLength = length2(p2 - p1);\n      segmentLengths\[i] = segmentLength;\n      totalLength += segmentLength;\n    \}\n\n    float targetLength = totalLength * (float)sampleIndex / (float)numSamples;\n    float currentLength = 0.0f;\n\n    for (int i = 0; i < numSegments; ++i) \{\n      if (currentLength + segmentLengths\[i] >= targetLength) \{\n        float segmentT = (targetLength - currentLength) / segmentLengths\[i];\n        return ((float)i + segmentT) / (float)numSegments;\n      \}\n      currentLength += segmentLengths\[i];\n    \}\n\n    return 1.0f;\n  \}\n\n  void process(int2 pos)\n  \{\n    float2 pixelPos = float2((float)(pos.x), (float)(pos.y));\n\n    float minDistSq = 1e10f;\n    float closest_t = 0.0f;\n    float2 closestPoint = pixelPos;\n    float2 closestTangent = float2(0.0f, 0.0f);\n\n    for (int i = 0; i <= numSamples; ++i)\n    \{\n      float t = normalizedSamplePosition(i);\n\n      float2 S_t = evaluateSpline(t);\n      float2 tangent = tangentSpline(t);\n\n      float2 diff = pixelPos - S_t;\n      float distSq = dot2(diff, diff);\n\n      if (distSq < minDistSq)\n      \{\n        minDistSq = distSq;\n        closestPoint = S_t;\n        closestTangent = tangent;\n        closest_t = t;\n      \}\n    \}\n\n    float dist = sqrt(minDistSq);\n    float width = getWidth(closest_t);\n\n    if (dist <= maxDistance * width)\n    \{\n      float U = closest_t;\n\n      float2 normal = float2(-closestTangent.y, closestTangent.x);\n      normal = normalize2(normal);\n\n      float side = dot2(pixelPos - closestPoint, normal);\n      float V = side / (maxDistance * width) * 0.5f + 0.5f; // Normalize V to \[0,1]\n\n      dst() = float4(U, V, 0.0f, 1.0f);\n    \}\n    else\n    \{\n      dst() = float4(0.0f, 0.0f, 0.0f, 0.0f);\n    \}\n  \}\n\};"
  rebuild ""
  "SplineUVMap_Number of Control Points" 6
  "SplineUVMap_Number of Samples" 400
  "SplineUVMap_Max Distance" 55
  SplineUVMap_Point0 {312 606}
  SplineUVMap_Point1 {484 1134}
  SplineUVMap_Point2 {840 910}
  SplineUVMap_Point3 {1008 514}
  SplineUVMap_Point4 {1460 642}
  SplineUVMap_Point5 {1544 950}
  specifiedFormat true
  rebuild_finalise ""
  name BlinkScript
  selected true
  xpos 656
  ypos 25
 }
 Dot {
  name Dot_FW
  label "this dot is used to locate the Blinkscript"
  note_font_size 10
  xpos 690
  ypos 84
 }
set Naf5e4800 [stack 0]
 Dot {
  name Dot10
  xpos 846
  ypos 147
 }
 FilterErode {
  size 0
  filter gaussian
  name FilterErode1
  xpos 812
  ypos 258
 }
push $Naf5e4800
 Blur {
  size {{parent.UVBLUR}}
  name Blur1
  xpos 656
  ypos 122
 }
 Input {
  inputs 0
  name Image
  xpos 455
  ypos 168
  number 1
 }
 STMap {
  inputs 2
  uv rgb
  name STMap2
  xpos 656
  ypos 207
 }
 Merge2 {
  inputs 2
  operation mask
  name Merge1
  xpos 656
  ypos 264
 }
 Output {
  name Output1
  xpos 656
  ypos 308
 }
 Input {
  inputs 0
  name Roto
  xpos 987
  ypos 199
 }
end_group
StickyNote {
 inputs 0
 name StickyNote1
 label "\"Counter Warping\" the image to make the shape \"proportions\"\nstay the same on the path."
 note_font_size 15
 xpos 1339
 ypos 137
}
StickyNote {
 inputs 0
 name StickyNote2
 label A.
 note_font_size 66
 xpos 1611
 ypos 56
}
ColorWheel {
 inputs 0
 gamma 0.45
 name ColorWheel2
 xpos 2682
 ypos 334
}
Reformat {
 type scale
 scale {7 1}
 resize none
 name Reformat1
 xpos 2675
 ypos 483
}
Group {
 name Offset1
 xpos 2675
 ypos 507
 addUserKnob {20 User l Offset}
 addUserKnob {12 offset}
 offset {{curve x1 0 x100 13900} {curve x1 0}}
 addUserKnob {14 tiles R 0 100}
 tiles 1
 addUserKnob {6 mx l "mirror x" +STARTLINE}
 addUserKnob {6 my l "mirror y" -STARTLINE}
 addUserKnob {41 filter T STMap1.filter}
 addUserKnob {26 ""}
 addUserKnob {41 motionblur T mb_trans.motionblur}
 addUserKnob {41 shutter T mb_trans.shutter}
 addUserKnob {41 shutteroffset l "shutter offset" T mb_trans.shutteroffset}
 addUserKnob {41 shuttercustomoffset l "" -STARTLINE T mb_trans.shuttercustomoffset}
 addUserKnob {20 about l @}
 addUserKnob {26 author l "Author: " T "Mariusz Wesierski ( mw@fxcalibur.com )"}
 addUserKnob {26 version l "Version: " T 1.0}
}
 Input {
  inputs 0
  name Input1
  xpos -301
  ypos -196
 }
set Na3d94000 [stack 0]
 Expression {
  expr0 ((x-offset.x)<0?1+((x-offset.x)/width*tiles.w)-int((x-offset.x)/width*tiles.w):((x-offset.x)/width*tiles.w)-int((x-offset.x)/width*tiles.w))
  expr1 ((y-offset.y)<0?1+((y-offset.y)/height*tiles.h)-int((y-offset.y)/height*tiles.h):((y-offset.y)/height*tiles.h)-int((y-offset.y)/height*tiles.h))
  expr2 0
  channel3 {none none none -rgba.alpha}
  name offset_xp
  xpos -422
  ypos -142
 }
 Expression {
  expr0 "mx?(x-offset.x>=0?0:1)+ fmod(int((x-offset.x)/width*tiles.w),2)!=0?1-r:r:r"
  expr1 "my?(y-offset.y>=0?0:1)+ fmod(int((y-offset.y)/height*tiles.h),2)!=0?1-g:g:g"
  channel2 {-rgba.red -rgba.green -rgba.blue none}
  channel3 none
  name mirror_xp
  xpos -422
  ypos -118
  disable {{mx?0:my?0:1}}
 }
push $Na3d94000
 STMap {
  inputs 2
  uv rgb
  blur_scale 0
  filter impulse
  name STMap1
  xpos -301
  ypos -124
 }
 Transform {
  translate {{offset.x i} {offset.y i}}
  center {800 501.5}
  filter impulse
  shutteroffset centred
  name mb_trans
  xpos -301
  ypos -81
  disable {{motionblur>0?0:1 i}}
 }
 Transform {
  translate {{-offset.x i} {-offset.y i}}
  center {800 501.5}
  filter impulse
  black_outside false
  name inv_trans
  xpos -301
  ypos -57
  disable {{mb_trans.motionblur>0?0:1 i}}
 }
 Output {
  name Output1
  xpos -301
  ypos -23
 }
end_group
Roto {
 inputs 0
 output alpha
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097152}
    {t x44800000 x44428000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup OpenSpline1 1049088 bezier
     {{cc
       {f 1056800}
       {px x43340000
        {xc0e00000 xc2940000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x42a60000 x44138000}
        {x40e00000 x42940000}
        {xc1f80000 xc29a0000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x42fa0000 x446d0000}
        {x41f80000 x429a0000}
        {xc2820000 xc1a00000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x43bb8000 x4491e000}
        {x42820000 x41a00000}
        {xc1400000 x41b80000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44220000 x4480a000}
        {x41400000 xc1b80000}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x442c8000 x441e4000}
        {0 0}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x444d4000 x43f18000}
        {0 0}
        {0 xc1d80000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44710000 x43e00000}
        {0 x41d80000}
        {xc0800000 xc1d80000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44840000 x44250000}
        {x40800000 x41d80000}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x449c0000 x4476c000}
        {0 0}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44b68000 x4487e000}
        {0 0}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44dfe000 x4481a000}
        {0 0}}}     idem}
     {tx x43340000 x44527a2f x444e1d17}
     {a osbe 0 osee 0 osw x41200000 osf 0 str 1 ltn x43340000 ltm x43340000 tt x41200000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createOpenSpline str 1 ssx 1 ssy 1 sf 1 tt 10 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {320 240}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 lifetime_start 180
 lifetime_end 180
 motionblur_shutter_offset_type centred
 name Roto2
 xpos 2227
 ypos 337
}
Group {
 inputs 2
 name CA_FlowWarp4
 tile_color 0x4c65ffff
 note_font "Verdana Bold"
 note_font_size 12
 note_font_color 0xe0cc30ff
 xpos 2227
 ypos 505
 addUserKnob {20 User}
 addUserKnob {41 format T BlinkScript.format}
 addUserKnob {26 d l " " T "Make sure format matches roto"}
 addUserKnob {26 ""}
 addUserKnob {22 SampleRoto l "Sample Roto" T "import nuke\nimport nuke.rotopaint as rp\n\n# Function to retrieve points from the Roto node's shapes and strokes\ndef get_roto_points(roto_node):\n    curves_knob = roto_node\['curves']\n    points = \[]\n    processed_elements = set()  # To track processed elements\n\n    # Access the root layer of the Roto node\n    root_layer = curves_knob.rootLayer\n\n    # Function to parse the layer and find shapes and strokes\n    def parse_layer(layer):\n        for element in layer:\n            element_id = id(element)  # Unique identifier for each element\n\n            # Check if the element is a Shape and not already processed\n            if isinstance(element, rp.Shape) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark element as processed\n\n                # Loop through the control points (CVs) in the shape\n                for point_idx, point in enumerate(element):\n                    frame = nuke.frame()\n                    # Get the position of the control vertex (center point)\n                    pos = point.center.getPosition(frame)\n                    points.append((pos\[0], pos\[1]))\n\n            # If the element is a Layer, process its contents\n            elif isinstance(element, rp.Layer) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark layer as processed\n                parse_layer(element)  # Recursively parse nested layers\n\n    # Parse the root layer to extract points\n    parse_layer(root_layer)\n    \n    return points\n\n# Main function to run the script and update the BlinkScript node\ndef main():\n    # Get the current node (the group node)\n    current_node = nuke.thisNode()\n\n    # Check if there is an input connected to the node (assuming input 0 is the roto node)\n    roto_node = current_node.input(0)\n    \n    if not roto_node or roto_node.Class() not in \['Roto', 'RotoPaint']:\n        nuke.message(\"Please connect a Roto or RotoPaint node to the current node.\")\n        return\n\n    # Get the points from the connected Roto or RotoPaint node\n    roto_points = get_roto_points(roto_node)\n    \n    if not roto_points:\n        nuke.message(\"No points found in the connected Roto node.\")\n        return\n    else:\n        # Begin the group to access internal nodes\n        current_node.begin()\n        # Find the BlinkScript node inside the group\n        blinkscript_node = None\n        blinkscript_node = nuke.toNode(current_node.name()+\".Dot_FW\").input(0)\n        \n        if blinkscript_node is None:\n            nuke.message(\"BlinkScript node not found inside the group.\")\n            current_node.end()\n            return\n\n        # Update the BlinkScript node parameters\n        # Set \"Number of Control Points\" to the number of points retrieved\n        blinkscript_node\['SplineUVMap_Number of Control Points'].setValue(len(roto_points))\n        # Update the positions of the points\n        max_points = 50  # Updated to support up to 50 points\n        for idx, point in enumerate(roto_points):\n            if idx >= max_points:\n                nuke.warning(f\"BlinkScript node supports a maximum of \{max_points\} points. Extra points are ignored.\")\n                break\n            # The point knobs are named \"SplineUVMap_Point0\", \"SplineUVMap_Point1\", etc.\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue(point)\n            else:\n                nuke.warning(f\"BlinkScript node does not have knob \{knob_name\}\")\n\n        # For any remaining Point knobs, set them to (0, 0)\n        for idx in range(len(roto_points), max_points):\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue((0.0, 0.0))\n\n        # End the group\n        current_node.end()\n\n# Execute the main function\nmain()" +STARTLINE}
 addUserKnob {41 "SplineUVMap_Number of Samples_1" l "Number of Samples" T "BlinkScript.SplineUVMap_Number of Samples"}
 addUserKnob {41 "SplineUVMap_Max Distance" l "Max Distance" T "BlinkScript.SplineUVMap_Max Distance"}
 addUserKnob {7 UVBLUR l "UV Blur" R 0 50}
 addUserKnob {41 "SplineUVMap_Curve Tightness" l "Curve Tightness" T "BlinkScript.SplineUVMap_Curve Tightness"}
 addUserKnob {41 "SplineUVMap_Normalize Samples" l "Normalize Samples" T "BlinkScript.SplineUVMap_Normalize Samples"}
 addUserKnob {26 explanation l Samples T "If you want your\nsamples evenly spread,\nnormalize them"}
 addUserKnob {26 ""}
 addUserKnob {41 "SplineUVMap_Number of Control Points" l "Number of Control Points" T "BlinkScript.SplineUVMap_Number of Control Points"}
 addUserKnob {26 _1 l Info: T "Auto detected from Sample Roto.  \nYou can put custom control points\nin group if you want."}
 addUserKnob {26 ""}
 addUserKnob {26 tapers l " " T "Taper Controls"}
 addUserKnob {41 "SplineUVMap_Width Start" l "Width Start" T "BlinkScript.SplineUVMap_Width Start"}
 addUserKnob {41 "SplineUVMap_Width Center" l "Width Center" T "BlinkScript.SplineUVMap_Width Center"}
 addUserKnob {41 "SplineUVMap_Width End" l "Width End" T "BlinkScript.SplineUVMap_Width End"}
 addUserKnob {26 ""}
 addUserKnob {26 Edge l "" -STARTLINE T "Edge Details"}
 addUserKnob {41 size l "Erode Edge" T FilterErode1.size}
 addUserKnob {41 filter l "Edge Filter" T FilterErode1.filter}
 addUserKnob {26 ""}
 addUserKnob {26 compacademy l " " T "For more:\nTools, Training, Epic Stock Footage:\n\nwww.compositingacademy.com\n\nMade in 2024"}
}
 BlinkScript {
  inputs 0
  recompileCount 2
  ProgramGroup 1
  KernelDescription "3 \"SplineUVMap\" iterate pixelWise 7323e521568e7c81daf69ed13b674e934e88cc6f9c6cb7a338b61e69790b719a 1 \"dst\" Write Point 58 \"Number of Control Points\" Int 1 BAAAAA== \"Number of Samples\" Int 1 ZAAAAA== \"Max Distance\" Float 1 AABIQg== \"Curve Tightness\" Float 1 AAAAAA== \"Width Start\" Float 1 AACAPw== \"Width Center\" Float 1 AACAPw== \"Width End\" Float 1 AACAPw== \"Normalize Samples\" Bool 1 AA== \"Point0\" Float 2 AAAAAAAAAAA= \"Point1\" Float 2 AAAAAAAAAAA= \"Point2\" Float 2 AAAAAAAAAAA= \"Point3\" Float 2 AAAAAAAAAAA= \"Point4\" Float 2 AAAAAAAAAAA= \"Point5\" Float 2 AAAAAAAAAAA= \"Point6\" Float 2 AAAAAAAAAAA= \"Point7\" Float 2 AAAAAAAAAAA= \"Point8\" Float 2 AAAAAAAAAAA= \"Point9\" Float 2 AAAAAAAAAAA= \"Point10\" Float 2 AAAAAAAAAAA= \"Point11\" Float 2 AAAAAAAAAAA= \"Point12\" Float 2 AAAAAAAAAAA= \"Point13\" Float 2 AAAAAAAAAAA= \"Point14\" Float 2 AAAAAAAAAAA= \"Point15\" Float 2 AAAAAAAAAAA= \"Point16\" Float 2 AAAAAAAAAAA= \"Point17\" Float 2 AAAAAAAAAAA= \"Point18\" Float 2 AAAAAAAAAAA= \"Point19\" Float 2 AAAAAAAAAAA= \"Point20\" Float 2 AAAAAAAAAAA= \"Point21\" Float 2 AAAAAAAAAAA= \"Point22\" Float 2 AAAAAAAAAAA= \"Point23\" Float 2 AAAAAAAAAAA= \"Point24\" Float 2 AAAAAAAAAAA= \"Point25\" Float 2 AAAAAAAAAAA= \"Point26\" Float 2 AAAAAAAAAAA= \"Point27\" Float 2 AAAAAAAAAAA= \"Point28\" Float 2 AAAAAAAAAAA= \"Point29\" Float 2 AAAAAAAAAAA= \"Point30\" Float 2 AAAAAAAAAAA= \"Point31\" Float 2 AAAAAAAAAAA= \"Point32\" Float 2 AAAAAAAAAAA= \"Point33\" Float 2 AAAAAAAAAAA= \"Point34\" Float 2 AAAAAAAAAAA= \"Point35\" Float 2 AAAAAAAAAAA= \"Point36\" Float 2 AAAAAAAAAAA= \"Point37\" Float 2 AAAAAAAAAAA= \"Point38\" Float 2 AAAAAAAAAAA= \"Point39\" Float 2 AAAAAAAAAAA= \"Point40\" Float 2 AAAAAAAAAAA= \"Point41\" Float 2 AAAAAAAAAAA= \"Point42\" Float 2 AAAAAAAAAAA= \"Point43\" Float 2 AAAAAAAAAAA= \"Point44\" Float 2 AAAAAAAAAAA= \"Point45\" Float 2 AAAAAAAAAAA= \"Point46\" Float 2 AAAAAAAAAAA= \"Point47\" Float 2 AAAAAAAAAAA= \"Point48\" Float 2 AAAAAAAAAAA= \"Point49\" Float 2 AAAAAAAAAAA= 58 \"numControlPoints\" 1 1 Default \"numSamples\" 1 1 Default \"maxDistance\" 1 1 Default \"tightness\" 1 1 Default \"widthStart\" 1 1 Default \"widthCenter\" 1 1 Default \"widthEnd\" 1 1 Default \"normalizeSamples\" 1 1 Default \"Point0\" 2 1 Default \"Point1\" 2 1 Default \"Point2\" 2 1 Default \"Point3\" 2 1 Default \"Point4\" 2 1 Default \"Point5\" 2 1 Default \"Point6\" 2 1 Default \"Point7\" 2 1 Default \"Point8\" 2 1 Default \"Point9\" 2 1 Default \"Point10\" 2 1 Default \"Point11\" 2 1 Default \"Point12\" 2 1 Default \"Point13\" 2 1 Default \"Point14\" 2 1 Default \"Point15\" 2 1 Default \"Point16\" 2 1 Default \"Point17\" 2 1 Default \"Point18\" 2 1 Default \"Point19\" 2 1 Default \"Point20\" 2 1 Default \"Point21\" 2 1 Default \"Point22\" 2 1 Default \"Point23\" 2 1 Default \"Point24\" 2 1 Default \"Point25\" 2 1 Default \"Point26\" 2 1 Default \"Point27\" 2 1 Default \"Point28\" 2 1 Default \"Point29\" 2 1 Default \"Point30\" 2 1 Default \"Point31\" 2 1 Default \"Point32\" 2 1 Default \"Point33\" 2 1 Default \"Point34\" 2 1 Default \"Point35\" 2 1 Default \"Point36\" 2 1 Default \"Point37\" 2 1 Default \"Point38\" 2 1 Default \"Point39\" 2 1 Default \"Point40\" 2 1 Default \"Point41\" 2 1 Default \"Point42\" 2 1 Default \"Point43\" 2 1 Default \"Point44\" 2 1 Default \"Point45\" 2 1 Default \"Point46\" 2 1 Default \"Point47\" 2 1 Default \"Point48\" 2 1 Default \"Point49\" 2 1 Default 0"
  kernelSource "kernel SplineUVMap : ImageComputationKernel<ePixelWise>\n\{\n  Image<eWrite> dst;\n\n  param:\n    int numControlPoints;\n    int numSamples;\n    float maxDistance;\n    float tightness;\n    float widthStart;\n    float widthCenter;\n    float widthEnd;\n    bool normalizeSamples;\n\n    // Define control points up to the maximum allowed (50 points)\n    float2 Point0;\n    float2 Point1;\n    float2 Point2;\n    float2 Point3;\n    float2 Point4;\n    float2 Point5;\n    float2 Point6;\n    float2 Point7;\n    float2 Point8;\n    float2 Point9;\n    float2 Point10;\n    float2 Point11;\n    float2 Point12;\n    float2 Point13;\n    float2 Point14;\n    float2 Point15;\n    float2 Point16;\n    float2 Point17;\n    float2 Point18;\n    float2 Point19;\n    float2 Point20;\n    float2 Point21;\n    float2 Point22;\n    float2 Point23;\n    float2 Point24;\n    float2 Point25;\n    float2 Point26;\n    float2 Point27;\n    float2 Point28;\n    float2 Point29;\n    float2 Point30;\n    float2 Point31;\n    float2 Point32;\n    float2 Point33;\n    float2 Point34;\n    float2 Point35;\n    float2 Point36;\n    float2 Point37;\n    float2 Point38;\n    float2 Point39;\n    float2 Point40;\n    float2 Point41;\n    float2 Point42;\n    float2 Point43;\n    float2 Point44;\n    float2 Point45;\n    float2 Point46;\n    float2 Point47;\n    float2 Point48;\n    float2 Point49;\n\n  void define()\n  \{\n    defineParam(numControlPoints, \"Number of Control Points\", 4);\n    defineParam(numSamples, \"Number of Samples\", 100);\n    defineParam(maxDistance, \"Max Distance\", 50.0f);\n    defineParam(tightness, \"Curve Tightness\", 0.0f); // 0 = smooth, 1 = linear\n    defineParam(widthStart, \"Width Start\", 1.0f);\n    defineParam(widthCenter, \"Width Center\", 1.0f);\n    defineParam(widthEnd, \"Width End\", 1.0f);\n    defineParam(normalizeSamples, \"Normalize Samples\", false);\n\n    // Define each control point parameter\n    defineParam(Point0, \"Point0\", float2(0.0f, 0.0f));\n    defineParam(Point1, \"Point1\", float2(0.0f, 0.0f));\n    defineParam(Point2, \"Point2\", float2(0.0f, 0.0f));\n    defineParam(Point3, \"Point3\", float2(0.0f, 0.0f));\n    defineParam(Point4, \"Point4\", float2(0.0f, 0.0f));\n    defineParam(Point5, \"Point5\", float2(0.0f, 0.0f));\n    defineParam(Point6, \"Point6\", float2(0.0f, 0.0f));\n    defineParam(Point7, \"Point7\", float2(0.0f, 0.0f));\n    defineParam(Point8, \"Point8\", float2(0.0f, 0.0f));\n    defineParam(Point9, \"Point9\", float2(0.0f, 0.0f));\n    defineParam(Point10, \"Point10\", float2(0.0f, 0.0f));\n    defineParam(Point11, \"Point11\", float2(0.0f, 0.0f));\n    defineParam(Point12, \"Point12\", float2(0.0f, 0.0f));\n    defineParam(Point13, \"Point13\", float2(0.0f, 0.0f));\n    defineParam(Point14, \"Point14\", float2(0.0f, 0.0f));\n    defineParam(Point15, \"Point15\", float2(0.0f, 0.0f));\n    defineParam(Point16, \"Point16\", float2(0.0f, 0.0f));\n    defineParam(Point17, \"Point17\", float2(0.0f, 0.0f));\n    defineParam(Point18, \"Point18\", float2(0.0f, 0.0f));\n    defineParam(Point19, \"Point19\", float2(0.0f, 0.0f));\n    defineParam(Point20, \"Point20\", float2(0.0f, 0.0f));\n    defineParam(Point21, \"Point21\", float2(0.0f, 0.0f));\n    defineParam(Point22, \"Point22\", float2(0.0f, 0.0f));\n    defineParam(Point23, \"Point23\", float2(0.0f, 0.0f));\n    defineParam(Point24, \"Point24\", float2(0.0f, 0.0f));\n    defineParam(Point25, \"Point25\", float2(0.0f, 0.0f));\n    defineParam(Point26, \"Point26\", float2(0.0f, 0.0f));\n    defineParam(Point27, \"Point27\", float2(0.0f, 0.0f));\n    defineParam(Point28, \"Point28\", float2(0.0f, 0.0f));\n    defineParam(Point29, \"Point29\", float2(0.0f, 0.0f));\n    defineParam(Point30, \"Point30\", float2(0.0f, 0.0f));\n    defineParam(Point31, \"Point31\", float2(0.0f, 0.0f));\n    defineParam(Point32, \"Point32\", float2(0.0f, 0.0f));\n    defineParam(Point33, \"Point33\", float2(0.0f, 0.0f));\n    defineParam(Point34, \"Point34\", float2(0.0f, 0.0f));\n    defineParam(Point35, \"Point35\", float2(0.0f, 0.0f));\n    defineParam(Point36, \"Point36\", float2(0.0f, 0.0f));\n    defineParam(Point37, \"Point37\", float2(0.0f, 0.0f));\n    defineParam(Point38, \"Point38\", float2(0.0f, 0.0f));\n    defineParam(Point39, \"Point39\", float2(0.0f, 0.0f));\n    defineParam(Point40, \"Point40\", float2(0.0f, 0.0f));\n    defineParam(Point41, \"Point41\", float2(0.0f, 0.0f));\n    defineParam(Point42, \"Point42\", float2(0.0f, 0.0f));\n    defineParam(Point43, \"Point43\", float2(0.0f, 0.0f));\n    defineParam(Point44, \"Point44\", float2(0.0f, 0.0f));\n    defineParam(Point45, \"Point45\", float2(0.0f, 0.0f));\n    defineParam(Point46, \"Point46\", float2(0.0f, 0.0f));\n    defineParam(Point47, \"Point47\", float2(0.0f, 0.0f));\n    defineParam(Point48, \"Point48\", float2(0.0f, 0.0f));\n    defineParam(Point49, \"Point49\", float2(0.0f, 0.0f));\n  \}\n\n  float dot2(float2 a, float2 b) \{\n    return a.x * b.x + a.y * b.y;\n  \}\n\n  float length2(float2 v) \{\n    return sqrt(v.x * v.x + v.y * v.y);\n  \}\n\n  float2 normalize2(float2 v) \{\n    float len = length2(v);\n    if (len > 0.0f) \{\n      return float2(v.x / len, v.y / len);\n    \} else \{\n      return float2(0.0f, 0.0f);\n    \}\n  \}\n\n  float2 evaluateSpline(float t)\n  \{\n    int numSegments = numControlPoints - 1;\n    float totalLength = (float)(numSegments);\n    float scaledT = t * totalLength;\n    int segment = (int)(floor(scaledT));\n    if (segment >= numSegments)\n      segment = numSegments - 1;\n    float localT = scaledT - (float)(segment);\n\n    int p0 = max(segment - 1, 0);\n    int p1 = segment;\n    int p2 = min(segment + 1, numControlPoints - 1);\n    int p3 = min(segment + 2, numControlPoints - 1);\n\n    float2 CP\[50];\n    CP\[0] = Point0;\n    CP\[1] = Point1;\n    CP\[2] = Point2;\n    CP\[3] = Point3;\n    CP\[4] = Point4;\n    CP\[5] = Point5;\n    CP\[6] = Point6;\n    CP\[7] = Point7;\n    CP\[8] = Point8;\n    CP\[9] = Point9;\n    CP\[10] = Point10;\n    CP\[11] = Point11;\n    CP\[12] = Point12;\n    CP\[13] = Point13;\n    CP\[14] = Point14;\n    CP\[15] = Point15;\n    CP\[16] = Point16;\n    CP\[17] = Point17;\n    CP\[18] = Point18;\n    CP\[19] = Point19;\n    CP\[20] = Point20;\n    CP\[21] = Point21;\n    CP\[22] = Point22;\n    CP\[23] = Point23;\n    CP\[24] = Point24;\n    CP\[25] = Point25;\n    CP\[26] = Point26;\n    CP\[27] = Point27;\n    CP\[28] = Point28;\n    CP\[29] = Point29;\n    CP\[30] = Point30;\n    CP\[31] = Point31;\n    CP\[32] = Point32;\n    CP\[33] = Point33;\n    CP\[34] = Point34;\n    CP\[35] = Point35;\n    CP\[36] = Point36;\n    CP\[37] = Point37;\n    CP\[38] = Point38;\n    CP\[39] = Point39;\n    CP\[40] = Point40;\n    CP\[41] = Point41;\n    CP\[42] = Point42;\n    CP\[43] = Point43;\n    CP\[44] = Point44;\n    CP\[45] = Point45;\n    CP\[46] = Point46;\n    CP\[47] = Point47;\n    CP\[48] = Point48;\n    CP\[49] = Point49;\n\n    float2 P0 = CP\[p0];\n    float2 P1 = CP\[p1];\n    float2 P2 = CP\[p2];\n    float2 P3 = CP\[p3];\n\n    // Linear interpolation\n    float2 linear = P1 + (P2 - P1) * localT;\n\n    // Catmull-Rom spline interpolation\n    float2 catmullRom = 0.5f * (\n      (2.0f * P1) +\n      (-P0 + P2) * localT +\n      (2.0f * P0 - 5.0f * P1 + 4.0f * P2 - P3) * localT * localT +\n      (-P0 + 3.0f * P1 - 3.0f * P2 + P3) * localT * localT * localT\n    );\n\n    // Interpolate between linear and Catmull-Rom based on tightness\n    return linear * tightness + catmullRom * (1.0f - tightness);\n  \}\n\n  float2 tangentSpline(float t)\n  \{\n    int numSegments = numControlPoints - 1;\n    float totalLength = (float)(numSegments);\n    float scaledT = t * totalLength;\n    int segment = (int)(floor(scaledT));\n    if (segment >= numSegments)\n      segment = numSegments - 1;\n    float localT = scaledT - (float)(segment);\n\n    int p0 = max(segment - 1, 0);\n    int p1 = segment;\n    int p2 = min(segment + 1, numControlPoints - 1);\n    int p3 = min(segment + 2, numControlPoints - 1);\n\n    float2 CP\[50];\n    CP\[0] = Point0;\n    CP\[1] = Point1;\n    CP\[2] = Point2;\n    CP\[3] = Point3;\n    CP\[4] = Point4;\n    CP\[5] = Point5;\n    CP\[6] = Point6;\n    CP\[7] = Point7;\n    CP\[8] = Point8;\n    CP\[9] = Point9;\n    CP\[10] = Point10;\n    CP\[11] = Point11;\n    CP\[12] = Point12;\n    CP\[13] = Point13;\n    CP\[14] = Point14;\n    CP\[15] = Point15;\n    CP\[16] = Point16;\n    CP\[17] = Point17;\n    CP\[18] = Point18;\n    CP\[19] = Point19;\n    CP\[20] = Point20;\n    CP\[21] = Point21;\n    CP\[22] = Point22;\n    CP\[23] = Point23;\n    CP\[24] = Point24;\n    CP\[25] = Point25;\n    CP\[26] = Point26;\n    CP\[27] = Point27;\n    CP\[28] = Point28;\n    CP\[29] = Point29;\n    CP\[30] = Point30;\n    CP\[31] = Point31;\n    CP\[32] = Point32;\n    CP\[33] = Point33;\n    CP\[34] = Point34;\n    CP\[35] = Point35;\n    CP\[36] = Point36;\n    CP\[37] = Point37;\n    CP\[38] = Point38;\n    CP\[39] = Point39;\n    CP\[40] = Point40;\n    CP\[41] = Point41;\n    CP\[42] = Point42;\n    CP\[43] = Point43;\n    CP\[44] = Point44;\n    CP\[45] = Point45;\n    CP\[46] = Point46;\n    CP\[47] = Point47;\n    CP\[48] = Point48;\n    CP\[49] = Point49;\n\n    float2 P0 = CP\[p0];\n    float2 P1 = CP\[p1];\n    float2 P2 = CP\[p2];\n    float2 P3 = CP\[p3];\n\n    // Linear tangent\n    float2 linearTangent = P2 - P1;\n// Catmull-Rom tangent (continued)\n    float2 catmullRomTangent = 0.5f * (\n      (-P0 + P2) +\n      2.0f * (2.0f * P0 - 5.0f * P1 + 4.0f * P2 - P3) * localT +\n      3.0f * (-P0 + 3.0f * P1 - 3.0f * P2 + P3) * localT * localT\n    );\n\n    // Interpolate between linear and Catmull-Rom tangents based on tightness\n    return normalize2(linearTangent * tightness + catmullRomTangent * (1.0f - tightness));\n  \}\n\n  float getWidth(float t)\n  \{\n    if (t < 0.5f) \{\n      return widthStart + (widthCenter - widthStart) * (t * 2.0f);\n    \} else \{\n      return widthCenter + (widthEnd - widthCenter) * ((t - 0.5f) * 2.0f);\n    \}\n  \}\n\n  float normalizedSamplePosition(int sampleIndex)\n  \{\n    if (!normalizeSamples) \{\n      return (float)sampleIndex / (float)numSamples;\n    \}\n\n    float totalLength = 0.0f;\n    float segmentLengths\[50];\n    int numSegments = numControlPoints - 1;\n\n    for (int i = 0; i < numSegments; ++i) \{\n      float2 p1 = evaluateSpline((float)i / (float)numSegments);\n      float2 p2 = evaluateSpline((float)(i + 1) / (float)numSegments);\n      float segmentLength = length2(p2 - p1);\n      segmentLengths\[i] = segmentLength;\n      totalLength += segmentLength;\n    \}\n\n    float targetLength = totalLength * (float)sampleIndex / (float)numSamples;\n    float currentLength = 0.0f;\n\n    for (int i = 0; i < numSegments; ++i) \{\n      if (currentLength + segmentLengths\[i] >= targetLength) \{\n        float segmentT = (targetLength - currentLength) / segmentLengths\[i];\n        return ((float)i + segmentT) / (float)numSegments;\n      \}\n      currentLength += segmentLengths\[i];\n    \}\n\n    return 1.0f;\n  \}\n\n  void process(int2 pos)\n  \{\n    float2 pixelPos = float2((float)(pos.x), (float)(pos.y));\n\n    float minDistSq = 1e10f;\n    float closest_t = 0.0f;\n    float2 closestPoint = pixelPos;\n    float2 closestTangent = float2(0.0f, 0.0f);\n\n    for (int i = 0; i <= numSamples; ++i)\n    \{\n      float t = normalizedSamplePosition(i);\n\n      float2 S_t = evaluateSpline(t);\n      float2 tangent = tangentSpline(t);\n\n      float2 diff = pixelPos - S_t;\n      float distSq = dot2(diff, diff);\n\n      if (distSq < minDistSq)\n      \{\n        minDistSq = distSq;\n        closestPoint = S_t;\n        closestTangent = tangent;\n        closest_t = t;\n      \}\n    \}\n\n    float dist = sqrt(minDistSq);\n    float width = getWidth(closest_t);\n\n    if (dist <= maxDistance * width)\n    \{\n      float U = closest_t;\n\n      float2 normal = float2(-closestTangent.y, closestTangent.x);\n      normal = normalize2(normal);\n\n      float side = dot2(pixelPos - closestPoint, normal);\n      float V = side / (maxDistance * width) * 0.5f + 0.5f; // Normalize V to \[0,1]\n\n      dst() = float4(U, V, 0.0f, 1.0f);\n    \}\n    else\n    \{\n      dst() = float4(0.0f, 0.0f, 0.0f, 0.0f);\n    \}\n  \}\n\};"
  rebuild ""
  "SplineUVMap_Number of Control Points" 11
  "SplineUVMap_Number of Samples" 400
  "SplineUVMap_Max Distance" 55
  SplineUVMap_Point0 {83 590}
  SplineUVMap_Point1 {125 948}
  SplineUVMap_Point2 {375 1167}
  SplineUVMap_Point3 {648 1029}
  SplineUVMap_Point4 {690 633}
  SplineUVMap_Point5 {821 483}
  SplineUVMap_Point6 {964 448}
  SplineUVMap_Point7 {1056 660}
  SplineUVMap_Point8 {1248 987}
  SplineUVMap_Point9 {1460 1087}
  SplineUVMap_Point10 {1791 1037}
  specifiedFormat true
  rebuild_finalise ""
  name BlinkScript
  selected true
  xpos 656
  ypos 25
 }
 Dot {
  name Dot_FW
  label "this dot is used to locate the Blinkscript"
  note_font_size 10
  xpos 690
  ypos 84
 }
set Na3e24400 [stack 0]
 Dot {
  name Dot10
  xpos 846
  ypos 147
 }
 FilterErode {
  size 0
  filter gaussian
  name FilterErode1
  xpos 812
  ypos 258
 }
push $Na3e24400
 Blur {
  size {{parent.UVBLUR}}
  name Blur1
  xpos 656
  ypos 122
 }
 Input {
  inputs 0
  name Image
  xpos 455
  ypos 168
  number 1
 }
 STMap {
  inputs 2
  uv rgb
  name STMap2
  xpos 656
  ypos 207
 }
 Merge2 {
  inputs 2
  operation mask
  name Merge1
  xpos 656
  ypos 264
 }
 Output {
  name Output1
  xpos 656
  ypos 308
 }
 Input {
  inputs 0
  name Roto
  xpos 987
  ypos 199
 }
end_group
Dot {
 name Dot3
 tile_color 0x84b9f2ff
 label "View Me"
 note_font_size 55
 xpos 2261
 ypos 760
}
FrameHold {
 firstFrame 29
 name FrameHold1
 xpos 2227
 ypos 794
}
StickyNote {
 inputs 0
 name StickyNote19
 tile_color 0x776dccff
 label "You can get 200 more effects like this in our alpha library.\n              Many top VFX Studios are already using our elements & Saving money on their FX Budgets.                  \n\n"
 note_font_size 44
 xpos 3732
 ypos 31
}
Group {
 inputs 0
 name CA_FlowWarp5
 tile_color 0x4c65ffff
 note_font "Verdana Bold"
 note_font_size 12
 note_font_color 0xe0cc30ff
 xpos -813
 ypos -313
 addUserKnob {20 User}
 addUserKnob {41 format T BlinkScript.format}
 addUserKnob {26 d l " " T "Make sure format matches roto"}
 addUserKnob {26 ""}
 addUserKnob {22 SampleRoto l "Sample Roto" T "import nuke\nimport nuke.rotopaint as rp\n\n# Function to retrieve points from the Roto node's shapes and strokes\ndef get_roto_points(roto_node):\n    curves_knob = roto_node\['curves']\n    points = \[]\n    processed_elements = set()  # To track processed elements\n\n    # Access the root layer of the Roto node\n    root_layer = curves_knob.rootLayer\n\n    # Function to parse the layer and find shapes and strokes\n    def parse_layer(layer):\n        for element in layer:\n            element_id = id(element)  # Unique identifier for each element\n\n            # Check if the element is a Shape and not already processed\n            if isinstance(element, rp.Shape) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark element as processed\n\n                # Loop through the control points (CVs) in the shape\n                for point_idx, point in enumerate(element):\n                    frame = nuke.frame()\n                    # Get the position of the control vertex (center point)\n                    pos = point.center.getPosition(frame)\n                    points.append((pos\[0], pos\[1]))\n\n            # If the element is a Layer, process its contents\n            elif isinstance(element, rp.Layer) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark layer as processed\n                parse_layer(element)  # Recursively parse nested layers\n\n    # Parse the root layer to extract points\n    parse_layer(root_layer)\n    \n    return points\n\n# Main function to run the script and update the BlinkScript node\ndef main():\n    # Get the current node (the group node)\n    current_node = nuke.thisNode()\n\n    # Check if there is an input connected to the node (assuming input 0 is the roto node)\n    roto_node = current_node.input(0)\n    \n    if not roto_node or roto_node.Class() not in \['Roto', 'RotoPaint']:\n        nuke.message(\"Please connect a Roto or RotoPaint node to the current node.\")\n        return\n\n    # Get the points from the connected Roto or RotoPaint node\n    roto_points = get_roto_points(roto_node)\n    \n    if not roto_points:\n        nuke.message(\"No points found in the connected Roto node.\")\n        return\n    else:\n        # Begin the group to access internal nodes\n        current_node.begin()\n        # Find the BlinkScript node inside the group\n        blinkscript_node = None\n        blinkscript_node = nuke.toNode(current_node.name()+\".Dot_FW\").input(0)\n        \n        if blinkscript_node is None:\n            nuke.message(\"BlinkScript node not found inside the group.\")\n            current_node.end()\n            return\n\n        # Update the BlinkScript node parameters\n        # Set \"Number of Control Points\" to the number of points retrieved\n        blinkscript_node\['SplineUVMap_Number of Control Points'].setValue(len(roto_points))\n        # Update the positions of the points\n        max_points = 50  # Updated to support up to 50 points\n        for idx, point in enumerate(roto_points):\n            if idx >= max_points:\n                nuke.warning(f\"BlinkScript node supports a maximum of \{max_points\} points. Extra points are ignored.\")\n                break\n            # The point knobs are named \"SplineUVMap_Point0\", \"SplineUVMap_Point1\", etc.\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue(point)\n            else:\n                nuke.warning(f\"BlinkScript node does not have knob \{knob_name\}\")\n\n        # For any remaining Point knobs, set them to (0, 0)\n        for idx in range(len(roto_points), max_points):\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue((0.0, 0.0))\n\n        # End the group\n        current_node.end()\n\n# Execute the main function\nmain()" +STARTLINE}
 addUserKnob {41 "SplineUVMap_Number of Samples_1" l "Number of Samples" T "BlinkScript.SplineUVMap_Number of Samples"}
 addUserKnob {41 "SplineUVMap_Max Distance" l "Max Distance" T "BlinkScript.SplineUVMap_Max Distance"}
 addUserKnob {7 UVBLUR l "UV Blur" R 0 50}
 addUserKnob {41 "SplineUVMap_Curve Tightness" l "Curve Tightness" T "BlinkScript.SplineUVMap_Curve Tightness"}
 addUserKnob {41 "SplineUVMap_Normalize Samples" l "Normalize Samples" T "BlinkScript.SplineUVMap_Normalize Samples"}
 addUserKnob {26 explanation l Samples T "If you want your\nsamples evenly spread,\nnormalize them"}
 addUserKnob {26 ""}
 addUserKnob {41 "SplineUVMap_Number of Control Points" l "Number of Control Points" T "BlinkScript.SplineUVMap_Number of Control Points"}
 addUserKnob {26 _1 l Info: T "Auto detected from Sample Roto.  \nYou can put custom control points\nin group if you want."}
 addUserKnob {26 ""}
 addUserKnob {26 tapers l " " T "Taper Controls"}
 addUserKnob {41 "SplineUVMap_Width Start" l "Width Start" T "BlinkScript.SplineUVMap_Width Start"}
 addUserKnob {41 "SplineUVMap_Width Center" l "Width Center" T "BlinkScript.SplineUVMap_Width Center"}
 addUserKnob {41 "SplineUVMap_Width End" l "Width End" T "BlinkScript.SplineUVMap_Width End"}
 addUserKnob {26 ""}
 addUserKnob {26 Edge l "" -STARTLINE T "Edge Details"}
 addUserKnob {41 size l "Erode Edge" T FilterErode1.size}
 addUserKnob {41 filter l "Edge Filter" T FilterErode1.filter}
 addUserKnob {26 ""}
 addUserKnob {26 compacademy l " " T "For more:\nTools, Training, Epic Stock Footage:\n\nwww.compositingacademy.com\n\nMade in 2024"}
}
 Dot {
  inputs 0
  name Dot_FW
  label "this dot is used to locate the Blinkscript"
  note_font_size 10
  xpos 690
  ypos 84
 }
set Na3e59000 [stack 0]
 Dot {
  name Dot10
  xpos 846
  ypos 147
 }
 FilterErode {
  size 0
  filter gaussian
  name FilterErode1
  xpos 812
  ypos 258
 }
push $Na3e59000
 Blur {
  size {{parent.UVBLUR}}
  name Blur1
  xpos 656
  ypos 122
 }
 Input {
  inputs 0
  name Image
  xpos 455
  ypos 168
  number 1
 }
 STMap {
  inputs 2
  uv rgb
  name STMap2
  xpos 656
  ypos 207
 }
 Merge2 {
  inputs 2
  operation mask
  name Merge1
  xpos 656
  ypos 264
 }
 Output {
  name Output1
  xpos 656
  ypos 308
 }
 Input {
  inputs 0
  name Roto
  xpos 987
  ypos 199
 }
end_group
Noise {
 inputs 0
 size 25.5
 gain 1
 gamma 0.185
 translate {390 0}
 center {1024 778}
 name Noise1
 xpos 121
 ypos 432
}
Roto {
 inputs 0
 output alpha
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097152}
    {t x44800000 x44428000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup OpenSpline1 1049088 bezier
     {{cc
       {f 1056800}
       {px x43340000
        {xc0e00000 xc2940000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x42a60000 x44138000}
        {x40e00000 x42940000}
        {xc1f80000 xc29a0000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x42fa0000 x446d0000}
        {x41f80000 x429a0000}
        {xc2820000 xc1a00000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x43bb8000 x4491e000}
        {x42820000 x41a00000}
        {xc1400000 x41b80000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44220000 x4480a000}
        {x41400000 xc1b80000}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x442c8000 x441e4000}
        {0 0}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x444d4000 x43f18000}
        {0 0}
        {0 xc1d80000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44710000 x43e00000}
        {0 x41d80000}
        {xc0800000 xc1d80000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44840000 x44250000}
        {x40800000 x41d80000}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x449c0000 x4476c000}
        {0 0}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44b68000 x4487e000}
        {0 0}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44dfe000 x4481a000}
        {0 0}}}     idem}
     {tx x43340000 x44527a2f x444e1d17}
     {a osbe 0 osee 0 osw x41200000 osf 0 str 1 ltn x43340000 ltm x43340000 tt x41200000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createOpenSpline str 1 ssx 1 ssy 1 sf 1 tt 10 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {320 240}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 lifetime_start 180
 lifetime_end 180
 motionblur_shutter_offset_type centred
 name Roto4
 xpos -134
 ypos 267
}
Group {
 inputs 2
 name CA_FlowWarp7
 tile_color 0x4c65ffff
 note_font "Verdana Bold"
 note_font_size 12
 note_font_color 0xe0cc30ff
 xpos -134
 ypos 430
 addUserKnob {20 User}
 addUserKnob {41 format T BlinkScript.format}
 addUserKnob {26 d l " " T "Make sure format matches roto"}
 addUserKnob {26 ""}
 addUserKnob {22 SampleRoto l "Sample Roto" T "import nuke\nimport nuke.rotopaint as rp\n\n# Function to retrieve points from the Roto node's shapes and strokes\ndef get_roto_points(roto_node):\n    curves_knob = roto_node\['curves']\n    points = \[]\n    processed_elements = set()  # To track processed elements\n\n    # Access the root layer of the Roto node\n    root_layer = curves_knob.rootLayer\n\n    # Function to parse the layer and find shapes and strokes\n    def parse_layer(layer):\n        for element in layer:\n            element_id = id(element)  # Unique identifier for each element\n\n            # Check if the element is a Shape and not already processed\n            if isinstance(element, rp.Shape) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark element as processed\n\n                # Loop through the control points (CVs) in the shape\n                for point_idx, point in enumerate(element):\n                    frame = nuke.frame()\n                    # Get the position of the control vertex (center point)\n                    pos = point.center.getPosition(frame)\n                    points.append((pos\[0], pos\[1]))\n\n            # If the element is a Layer, process its contents\n            elif isinstance(element, rp.Layer) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark layer as processed\n                parse_layer(element)  # Recursively parse nested layers\n\n    # Parse the root layer to extract points\n    parse_layer(root_layer)\n    \n    return points\n\n# Main function to run the script and update the BlinkScript node\ndef main():\n    # Get the current node (the group node)\n    current_node = nuke.thisNode()\n\n    # Check if there is an input connected to the node (assuming input 0 is the roto node)\n    roto_node = current_node.input(0)\n    \n    if not roto_node or roto_node.Class() not in \['Roto', 'RotoPaint']:\n        nuke.message(\"Please connect a Roto or RotoPaint node to the current node.\")\n        return\n\n    # Get the points from the connected Roto or RotoPaint node\n    roto_points = get_roto_points(roto_node)\n    \n    if not roto_points:\n        nuke.message(\"No points found in the connected Roto node.\")\n        return\n    else:\n        # Begin the group to access internal nodes\n        current_node.begin()\n        # Find the BlinkScript node inside the group\n        blinkscript_node = None\n        blinkscript_node = nuke.toNode(current_node.name()+\".Dot_FW\").input(0)\n        \n        if blinkscript_node is None:\n            nuke.message(\"BlinkScript node not found inside the group.\")\n            current_node.end()\n            return\n\n        # Update the BlinkScript node parameters\n        # Set \"Number of Control Points\" to the number of points retrieved\n        blinkscript_node\['SplineUVMap_Number of Control Points'].setValue(len(roto_points))\n        # Update the positions of the points\n        max_points = 50  # Updated to support up to 50 points\n        for idx, point in enumerate(roto_points):\n            if idx >= max_points:\n                nuke.warning(f\"BlinkScript node supports a maximum of \{max_points\} points. Extra points are ignored.\")\n                break\n            # The point knobs are named \"SplineUVMap_Point0\", \"SplineUVMap_Point1\", etc.\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue(point)\n            else:\n                nuke.warning(f\"BlinkScript node does not have knob \{knob_name\}\")\n\n        # For any remaining Point knobs, set them to (0, 0)\n        for idx in range(len(roto_points), max_points):\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue((0.0, 0.0))\n\n        # End the group\n        current_node.end()\n\n# Execute the main function\nmain()" +STARTLINE}
 addUserKnob {41 "SplineUVMap_Number of Samples_1" l "Number of Samples" T "BlinkScript.SplineUVMap_Number of Samples"}
 addUserKnob {41 "SplineUVMap_Max Distance" l "Max Distance" T "BlinkScript.SplineUVMap_Max Distance"}
 addUserKnob {7 UVBLUR l "UV Blur" R 0 50}
 addUserKnob {41 "SplineUVMap_Curve Tightness" l "Curve Tightness" T "BlinkScript.SplineUVMap_Curve Tightness"}
 addUserKnob {41 "SplineUVMap_Normalize Samples" l "Normalize Samples" T "BlinkScript.SplineUVMap_Normalize Samples"}
 addUserKnob {26 explanation l Samples T "If you want your\nsamples evenly spread,\nnormalize them"}
 addUserKnob {26 ""}
 addUserKnob {41 "SplineUVMap_Number of Control Points" l "Number of Control Points" T "BlinkScript.SplineUVMap_Number of Control Points"}
 addUserKnob {26 _1 l Info: T "Auto detected from Sample Roto.  \nYou can put custom control points\nin group if you want."}
 addUserKnob {26 ""}
 addUserKnob {26 tapers l " " T "Taper Controls"}
 addUserKnob {41 "SplineUVMap_Width Start" l "Width Start" T "BlinkScript.SplineUVMap_Width Start"}
 addUserKnob {41 "SplineUVMap_Width Center" l "Width Center" T "BlinkScript.SplineUVMap_Width Center"}
 addUserKnob {41 "SplineUVMap_Width End" l "Width End" T "BlinkScript.SplineUVMap_Width End"}
 addUserKnob {26 ""}
 addUserKnob {26 Edge l "" -STARTLINE T "Edge Details"}
 addUserKnob {41 size l "Erode Edge" T FilterErode1.size}
 addUserKnob {41 filter l "Edge Filter" T FilterErode1.filter}
 addUserKnob {26 ""}
 addUserKnob {26 compacademy l " " T "For more:\nTools, Training, Epic Stock Footage:\n\nwww.compositingacademy.com\n\nMade in 2024"}
}
 BlinkScript {
  inputs 0
  recompileCount 2
  ProgramGroup 1
  KernelDescription "3 \"SplineUVMap\" iterate pixelWise 7323e521568e7c81daf69ed13b674e934e88cc6f9c6cb7a338b61e69790b719a 1 \"dst\" Write Point 58 \"Number of Control Points\" Int 1 BAAAAA== \"Number of Samples\" Int 1 ZAAAAA== \"Max Distance\" Float 1 AABIQg== \"Curve Tightness\" Float 1 AAAAAA== \"Width Start\" Float 1 AACAPw== \"Width Center\" Float 1 AACAPw== \"Width End\" Float 1 AACAPw== \"Normalize Samples\" Bool 1 AA== \"Point0\" Float 2 AAAAAAAAAAA= \"Point1\" Float 2 AAAAAAAAAAA= \"Point2\" Float 2 AAAAAAAAAAA= \"Point3\" Float 2 AAAAAAAAAAA= \"Point4\" Float 2 AAAAAAAAAAA= \"Point5\" Float 2 AAAAAAAAAAA= \"Point6\" Float 2 AAAAAAAAAAA= \"Point7\" Float 2 AAAAAAAAAAA= \"Point8\" Float 2 AAAAAAAAAAA= \"Point9\" Float 2 AAAAAAAAAAA= \"Point10\" Float 2 AAAAAAAAAAA= \"Point11\" Float 2 AAAAAAAAAAA= \"Point12\" Float 2 AAAAAAAAAAA= \"Point13\" Float 2 AAAAAAAAAAA= \"Point14\" Float 2 AAAAAAAAAAA= \"Point15\" Float 2 AAAAAAAAAAA= \"Point16\" Float 2 AAAAAAAAAAA= \"Point17\" Float 2 AAAAAAAAAAA= \"Point18\" Float 2 AAAAAAAAAAA= \"Point19\" Float 2 AAAAAAAAAAA= \"Point20\" Float 2 AAAAAAAAAAA= \"Point21\" Float 2 AAAAAAAAAAA= \"Point22\" Float 2 AAAAAAAAAAA= \"Point23\" Float 2 AAAAAAAAAAA= \"Point24\" Float 2 AAAAAAAAAAA= \"Point25\" Float 2 AAAAAAAAAAA= \"Point26\" Float 2 AAAAAAAAAAA= \"Point27\" Float 2 AAAAAAAAAAA= \"Point28\" Float 2 AAAAAAAAAAA= \"Point29\" Float 2 AAAAAAAAAAA= \"Point30\" Float 2 AAAAAAAAAAA= \"Point31\" Float 2 AAAAAAAAAAA= \"Point32\" Float 2 AAAAAAAAAAA= \"Point33\" Float 2 AAAAAAAAAAA= \"Point34\" Float 2 AAAAAAAAAAA= \"Point35\" Float 2 AAAAAAAAAAA= \"Point36\" Float 2 AAAAAAAAAAA= \"Point37\" Float 2 AAAAAAAAAAA= \"Point38\" Float 2 AAAAAAAAAAA= \"Point39\" Float 2 AAAAAAAAAAA= \"Point40\" Float 2 AAAAAAAAAAA= \"Point41\" Float 2 AAAAAAAAAAA= \"Point42\" Float 2 AAAAAAAAAAA= \"Point43\" Float 2 AAAAAAAAAAA= \"Point44\" Float 2 AAAAAAAAAAA= \"Point45\" Float 2 AAAAAAAAAAA= \"Point46\" Float 2 AAAAAAAAAAA= \"Point47\" Float 2 AAAAAAAAAAA= \"Point48\" Float 2 AAAAAAAAAAA= \"Point49\" Float 2 AAAAAAAAAAA= 58 \"numControlPoints\" 1 1 Default \"numSamples\" 1 1 Default \"maxDistance\" 1 1 Default \"tightness\" 1 1 Default \"widthStart\" 1 1 Default \"widthCenter\" 1 1 Default \"widthEnd\" 1 1 Default \"normalizeSamples\" 1 1 Default \"Point0\" 2 1 Default \"Point1\" 2 1 Default \"Point2\" 2 1 Default \"Point3\" 2 1 Default \"Point4\" 2 1 Default \"Point5\" 2 1 Default \"Point6\" 2 1 Default \"Point7\" 2 1 Default \"Point8\" 2 1 Default \"Point9\" 2 1 Default \"Point10\" 2 1 Default \"Point11\" 2 1 Default \"Point12\" 2 1 Default \"Point13\" 2 1 Default \"Point14\" 2 1 Default \"Point15\" 2 1 Default \"Point16\" 2 1 Default \"Point17\" 2 1 Default \"Point18\" 2 1 Default \"Point19\" 2 1 Default \"Point20\" 2 1 Default \"Point21\" 2 1 Default \"Point22\" 2 1 Default \"Point23\" 2 1 Default \"Point24\" 2 1 Default \"Point25\" 2 1 Default \"Point26\" 2 1 Default \"Point27\" 2 1 Default \"Point28\" 2 1 Default \"Point29\" 2 1 Default \"Point30\" 2 1 Default \"Point31\" 2 1 Default \"Point32\" 2 1 Default \"Point33\" 2 1 Default \"Point34\" 2 1 Default \"Point35\" 2 1 Default \"Point36\" 2 1 Default \"Point37\" 2 1 Default \"Point38\" 2 1 Default \"Point39\" 2 1 Default \"Point40\" 2 1 Default \"Point41\" 2 1 Default \"Point42\" 2 1 Default \"Point43\" 2 1 Default \"Point44\" 2 1 Default \"Point45\" 2 1 Default \"Point46\" 2 1 Default \"Point47\" 2 1 Default \"Point48\" 2 1 Default \"Point49\" 2 1 Default 0"
  kernelSource "kernel SplineUVMap : ImageComputationKernel<ePixelWise>\n\{\n  Image<eWrite> dst;\n\n  param:\n    int numControlPoints;\n    int numSamples;\n    float maxDistance;\n    float tightness;\n    float widthStart;\n    float widthCenter;\n    float widthEnd;\n    bool normalizeSamples;\n\n    // Define control points up to the maximum allowed (50 points)\n    float2 Point0;\n    float2 Point1;\n    float2 Point2;\n    float2 Point3;\n    float2 Point4;\n    float2 Point5;\n    float2 Point6;\n    float2 Point7;\n    float2 Point8;\n    float2 Point9;\n    float2 Point10;\n    float2 Point11;\n    float2 Point12;\n    float2 Point13;\n    float2 Point14;\n    float2 Point15;\n    float2 Point16;\n    float2 Point17;\n    float2 Point18;\n    float2 Point19;\n    float2 Point20;\n    float2 Point21;\n    float2 Point22;\n    float2 Point23;\n    float2 Point24;\n    float2 Point25;\n    float2 Point26;\n    float2 Point27;\n    float2 Point28;\n    float2 Point29;\n    float2 Point30;\n    float2 Point31;\n    float2 Point32;\n    float2 Point33;\n    float2 Point34;\n    float2 Point35;\n    float2 Point36;\n    float2 Point37;\n    float2 Point38;\n    float2 Point39;\n    float2 Point40;\n    float2 Point41;\n    float2 Point42;\n    float2 Point43;\n    float2 Point44;\n    float2 Point45;\n    float2 Point46;\n    float2 Point47;\n    float2 Point48;\n    float2 Point49;\n\n  void define()\n  \{\n    defineParam(numControlPoints, \"Number of Control Points\", 4);\n    defineParam(numSamples, \"Number of Samples\", 100);\n    defineParam(maxDistance, \"Max Distance\", 50.0f);\n    defineParam(tightness, \"Curve Tightness\", 0.0f); // 0 = smooth, 1 = linear\n    defineParam(widthStart, \"Width Start\", 1.0f);\n    defineParam(widthCenter, \"Width Center\", 1.0f);\n    defineParam(widthEnd, \"Width End\", 1.0f);\n    defineParam(normalizeSamples, \"Normalize Samples\", false);\n\n    // Define each control point parameter\n    defineParam(Point0, \"Point0\", float2(0.0f, 0.0f));\n    defineParam(Point1, \"Point1\", float2(0.0f, 0.0f));\n    defineParam(Point2, \"Point2\", float2(0.0f, 0.0f));\n    defineParam(Point3, \"Point3\", float2(0.0f, 0.0f));\n    defineParam(Point4, \"Point4\", float2(0.0f, 0.0f));\n    defineParam(Point5, \"Point5\", float2(0.0f, 0.0f));\n    defineParam(Point6, \"Point6\", float2(0.0f, 0.0f));\n    defineParam(Point7, \"Point7\", float2(0.0f, 0.0f));\n    defineParam(Point8, \"Point8\", float2(0.0f, 0.0f));\n    defineParam(Point9, \"Point9\", float2(0.0f, 0.0f));\n    defineParam(Point10, \"Point10\", float2(0.0f, 0.0f));\n    defineParam(Point11, \"Point11\", float2(0.0f, 0.0f));\n    defineParam(Point12, \"Point12\", float2(0.0f, 0.0f));\n    defineParam(Point13, \"Point13\", float2(0.0f, 0.0f));\n    defineParam(Point14, \"Point14\", float2(0.0f, 0.0f));\n    defineParam(Point15, \"Point15\", float2(0.0f, 0.0f));\n    defineParam(Point16, \"Point16\", float2(0.0f, 0.0f));\n    defineParam(Point17, \"Point17\", float2(0.0f, 0.0f));\n    defineParam(Point18, \"Point18\", float2(0.0f, 0.0f));\n    defineParam(Point19, \"Point19\", float2(0.0f, 0.0f));\n    defineParam(Point20, \"Point20\", float2(0.0f, 0.0f));\n    defineParam(Point21, \"Point21\", float2(0.0f, 0.0f));\n    defineParam(Point22, \"Point22\", float2(0.0f, 0.0f));\n    defineParam(Point23, \"Point23\", float2(0.0f, 0.0f));\n    defineParam(Point24, \"Point24\", float2(0.0f, 0.0f));\n    defineParam(Point25, \"Point25\", float2(0.0f, 0.0f));\n    defineParam(Point26, \"Point26\", float2(0.0f, 0.0f));\n    defineParam(Point27, \"Point27\", float2(0.0f, 0.0f));\n    defineParam(Point28, \"Point28\", float2(0.0f, 0.0f));\n    defineParam(Point29, \"Point29\", float2(0.0f, 0.0f));\n    defineParam(Point30, \"Point30\", float2(0.0f, 0.0f));\n    defineParam(Point31, \"Point31\", float2(0.0f, 0.0f));\n    defineParam(Point32, \"Point32\", float2(0.0f, 0.0f));\n    defineParam(Point33, \"Point33\", float2(0.0f, 0.0f));\n    defineParam(Point34, \"Point34\", float2(0.0f, 0.0f));\n    defineParam(Point35, \"Point35\", float2(0.0f, 0.0f));\n    defineParam(Point36, \"Point36\", float2(0.0f, 0.0f));\n    defineParam(Point37, \"Point37\", float2(0.0f, 0.0f));\n    defineParam(Point38, \"Point38\", float2(0.0f, 0.0f));\n    defineParam(Point39, \"Point39\", float2(0.0f, 0.0f));\n    defineParam(Point40, \"Point40\", float2(0.0f, 0.0f));\n    defineParam(Point41, \"Point41\", float2(0.0f, 0.0f));\n    defineParam(Point42, \"Point42\", float2(0.0f, 0.0f));\n    defineParam(Point43, \"Point43\", float2(0.0f, 0.0f));\n    defineParam(Point44, \"Point44\", float2(0.0f, 0.0f));\n    defineParam(Point45, \"Point45\", float2(0.0f, 0.0f));\n    defineParam(Point46, \"Point46\", float2(0.0f, 0.0f));\n    defineParam(Point47, \"Point47\", float2(0.0f, 0.0f));\n    defineParam(Point48, \"Point48\", float2(0.0f, 0.0f));\n    defineParam(Point49, \"Point49\", float2(0.0f, 0.0f));\n  \}\n\n  float dot2(float2 a, float2 b) \{\n    return a.x * b.x + a.y * b.y;\n  \}\n\n  float length2(float2 v) \{\n    return sqrt(v.x * v.x + v.y * v.y);\n  \}\n\n  float2 normalize2(float2 v) \{\n    float len = length2(v);\n    if (len > 0.0f) \{\n      return float2(v.x / len, v.y / len);\n    \} else \{\n      return float2(0.0f, 0.0f);\n    \}\n  \}\n\n  float2 evaluateSpline(float t)\n  \{\n    int numSegments = numControlPoints - 1;\n    float totalLength = (float)(numSegments);\n    float scaledT = t * totalLength;\n    int segment = (int)(floor(scaledT));\n    if (segment >= numSegments)\n      segment = numSegments - 1;\n    float localT = scaledT - (float)(segment);\n\n    int p0 = max(segment - 1, 0);\n    int p1 = segment;\n    int p2 = min(segment + 1, numControlPoints - 1);\n    int p3 = min(segment + 2, numControlPoints - 1);\n\n    float2 CP\[50];\n    CP\[0] = Point0;\n    CP\[1] = Point1;\n    CP\[2] = Point2;\n    CP\[3] = Point3;\n    CP\[4] = Point4;\n    CP\[5] = Point5;\n    CP\[6] = Point6;\n    CP\[7] = Point7;\n    CP\[8] = Point8;\n    CP\[9] = Point9;\n    CP\[10] = Point10;\n    CP\[11] = Point11;\n    CP\[12] = Point12;\n    CP\[13] = Point13;\n    CP\[14] = Point14;\n    CP\[15] = Point15;\n    CP\[16] = Point16;\n    CP\[17] = Point17;\n    CP\[18] = Point18;\n    CP\[19] = Point19;\n    CP\[20] = Point20;\n    CP\[21] = Point21;\n    CP\[22] = Point22;\n    CP\[23] = Point23;\n    CP\[24] = Point24;\n    CP\[25] = Point25;\n    CP\[26] = Point26;\n    CP\[27] = Point27;\n    CP\[28] = Point28;\n    CP\[29] = Point29;\n    CP\[30] = Point30;\n    CP\[31] = Point31;\n    CP\[32] = Point32;\n    CP\[33] = Point33;\n    CP\[34] = Point34;\n    CP\[35] = Point35;\n    CP\[36] = Point36;\n    CP\[37] = Point37;\n    CP\[38] = Point38;\n    CP\[39] = Point39;\n    CP\[40] = Point40;\n    CP\[41] = Point41;\n    CP\[42] = Point42;\n    CP\[43] = Point43;\n    CP\[44] = Point44;\n    CP\[45] = Point45;\n    CP\[46] = Point46;\n    CP\[47] = Point47;\n    CP\[48] = Point48;\n    CP\[49] = Point49;\n\n    float2 P0 = CP\[p0];\n    float2 P1 = CP\[p1];\n    float2 P2 = CP\[p2];\n    float2 P3 = CP\[p3];\n\n    // Linear interpolation\n    float2 linear = P1 + (P2 - P1) * localT;\n\n    // Catmull-Rom spline interpolation\n    float2 catmullRom = 0.5f * (\n      (2.0f * P1) +\n      (-P0 + P2) * localT +\n      (2.0f * P0 - 5.0f * P1 + 4.0f * P2 - P3) * localT * localT +\n      (-P0 + 3.0f * P1 - 3.0f * P2 + P3) * localT * localT * localT\n    );\n\n    // Interpolate between linear and Catmull-Rom based on tightness\n    return linear * tightness + catmullRom * (1.0f - tightness);\n  \}\n\n  float2 tangentSpline(float t)\n  \{\n    int numSegments = numControlPoints - 1;\n    float totalLength = (float)(numSegments);\n    float scaledT = t * totalLength;\n    int segment = (int)(floor(scaledT));\n    if (segment >= numSegments)\n      segment = numSegments - 1;\n    float localT = scaledT - (float)(segment);\n\n    int p0 = max(segment - 1, 0);\n    int p1 = segment;\n    int p2 = min(segment + 1, numControlPoints - 1);\n    int p3 = min(segment + 2, numControlPoints - 1);\n\n    float2 CP\[50];\n    CP\[0] = Point0;\n    CP\[1] = Point1;\n    CP\[2] = Point2;\n    CP\[3] = Point3;\n    CP\[4] = Point4;\n    CP\[5] = Point5;\n    CP\[6] = Point6;\n    CP\[7] = Point7;\n    CP\[8] = Point8;\n    CP\[9] = Point9;\n    CP\[10] = Point10;\n    CP\[11] = Point11;\n    CP\[12] = Point12;\n    CP\[13] = Point13;\n    CP\[14] = Point14;\n    CP\[15] = Point15;\n    CP\[16] = Point16;\n    CP\[17] = Point17;\n    CP\[18] = Point18;\n    CP\[19] = Point19;\n    CP\[20] = Point20;\n    CP\[21] = Point21;\n    CP\[22] = Point22;\n    CP\[23] = Point23;\n    CP\[24] = Point24;\n    CP\[25] = Point25;\n    CP\[26] = Point26;\n    CP\[27] = Point27;\n    CP\[28] = Point28;\n    CP\[29] = Point29;\n    CP\[30] = Point30;\n    CP\[31] = Point31;\n    CP\[32] = Point32;\n    CP\[33] = Point33;\n    CP\[34] = Point34;\n    CP\[35] = Point35;\n    CP\[36] = Point36;\n    CP\[37] = Point37;\n    CP\[38] = Point38;\n    CP\[39] = Point39;\n    CP\[40] = Point40;\n    CP\[41] = Point41;\n    CP\[42] = Point42;\n    CP\[43] = Point43;\n    CP\[44] = Point44;\n    CP\[45] = Point45;\n    CP\[46] = Point46;\n    CP\[47] = Point47;\n    CP\[48] = Point48;\n    CP\[49] = Point49;\n\n    float2 P0 = CP\[p0];\n    float2 P1 = CP\[p1];\n    float2 P2 = CP\[p2];\n    float2 P3 = CP\[p3];\n\n    // Linear tangent\n    float2 linearTangent = P2 - P1;\n// Catmull-Rom tangent (continued)\n    float2 catmullRomTangent = 0.5f * (\n      (-P0 + P2) +\n      2.0f * (2.0f * P0 - 5.0f * P1 + 4.0f * P2 - P3) * localT +\n      3.0f * (-P0 + 3.0f * P1 - 3.0f * P2 + P3) * localT * localT\n    );\n\n    // Interpolate between linear and Catmull-Rom tangents based on tightness\n    return normalize2(linearTangent * tightness + catmullRomTangent * (1.0f - tightness));\n  \}\n\n  float getWidth(float t)\n  \{\n    if (t < 0.5f) \{\n      return widthStart + (widthCenter - widthStart) * (t * 2.0f);\n    \} else \{\n      return widthCenter + (widthEnd - widthCenter) * ((t - 0.5f) * 2.0f);\n    \}\n  \}\n\n  float normalizedSamplePosition(int sampleIndex)\n  \{\n    if (!normalizeSamples) \{\n      return (float)sampleIndex / (float)numSamples;\n    \}\n\n    float totalLength = 0.0f;\n    float segmentLengths\[50];\n    int numSegments = numControlPoints - 1;\n\n    for (int i = 0; i < numSegments; ++i) \{\n      float2 p1 = evaluateSpline((float)i / (float)numSegments);\n      float2 p2 = evaluateSpline((float)(i + 1) / (float)numSegments);\n      float segmentLength = length2(p2 - p1);\n      segmentLengths\[i] = segmentLength;\n      totalLength += segmentLength;\n    \}\n\n    float targetLength = totalLength * (float)sampleIndex / (float)numSamples;\n    float currentLength = 0.0f;\n\n    for (int i = 0; i < numSegments; ++i) \{\n      if (currentLength + segmentLengths\[i] >= targetLength) \{\n        float segmentT = (targetLength - currentLength) / segmentLengths\[i];\n        return ((float)i + segmentT) / (float)numSegments;\n      \}\n      currentLength += segmentLengths\[i];\n    \}\n\n    return 1.0f;\n  \}\n\n  void process(int2 pos)\n  \{\n    float2 pixelPos = float2((float)(pos.x), (float)(pos.y));\n\n    float minDistSq = 1e10f;\n    float closest_t = 0.0f;\n    float2 closestPoint = pixelPos;\n    float2 closestTangent = float2(0.0f, 0.0f);\n\n    for (int i = 0; i <= numSamples; ++i)\n    \{\n      float t = normalizedSamplePosition(i);\n\n      float2 S_t = evaluateSpline(t);\n      float2 tangent = tangentSpline(t);\n\n      float2 diff = pixelPos - S_t;\n      float distSq = dot2(diff, diff);\n\n      if (distSq < minDistSq)\n      \{\n        minDistSq = distSq;\n        closestPoint = S_t;\n        closestTangent = tangent;\n        closest_t = t;\n      \}\n    \}\n\n    float dist = sqrt(minDistSq);\n    float width = getWidth(closest_t);\n\n    if (dist <= maxDistance * width)\n    \{\n      float U = closest_t;\n\n      float2 normal = float2(-closestTangent.y, closestTangent.x);\n      normal = normalize2(normal);\n\n      float side = dot2(pixelPos - closestPoint, normal);\n      float V = side / (maxDistance * width) * 0.5f + 0.5f; // Normalize V to \[0,1]\n\n      dst() = float4(U, V, 0.0f, 1.0f);\n    \}\n    else\n    \{\n      dst() = float4(0.0f, 0.0f, 0.0f, 0.0f);\n    \}\n  \}\n\};"
  rebuild ""
  "SplineUVMap_Number of Control Points" 6
  "SplineUVMap_Number of Samples" 400
  "SplineUVMap_Max Distance" 55
  SplineUVMap_Point0 {312 606}
  SplineUVMap_Point1 {484 1134}
  SplineUVMap_Point2 {840 910}
  SplineUVMap_Point3 {1008 514}
  SplineUVMap_Point4 {1460 642}
  SplineUVMap_Point5 {1544 950}
  specifiedFormat true
  rebuild_finalise ""
  name BlinkScript
  selected true
  xpos 656
  ypos 25
 }
 Dot {
  name Dot_FW
  label "this dot is used to locate the Blinkscript"
  note_font_size 10
  xpos 690
  ypos 84
 }
set Na4046000 [stack 0]
 Dot {
  name Dot10
  xpos 846
  ypos 147
 }
 FilterErode {
  size 0
  filter gaussian
  name FilterErode1
  xpos 812
  ypos 258
 }
push $Na4046000
 Blur {
  size {{parent.UVBLUR}}
  name Blur1
  xpos 656
  ypos 122
 }
 Input {
  inputs 0
  name Image
  xpos 455
  ypos 168
  number 1
 }
 STMap {
  inputs 2
  uv rgb
  name STMap2
  xpos 656
  ypos 207
 }
 Merge2 {
  inputs 2
  operation mask
  name Merge1
  xpos 656
  ypos 264
 }
 Output {
  name Output1
  xpos 656
  ypos 308
 }
 Input {
  inputs 0
  name Roto
  xpos 987
  ypos 199
 }
end_group
Read {
 inputs 0
 file_type exr
 file "Laser Beam Asset (Free, Enjoy!)/eb_CW_###.exr"
 format "4096 4096 0 0 4096 4096 1 square_4k"
 first 15
 last 500
 origfirst 15
 origlast 500
 origset true
 version 1
 name Read2
 tile_color 0xcf04d1ff
 xpos 4733
 ypos 252
}
TimeOffset {
 time_offset -20
 time ""
 name TimeOffset1
 xpos 4733
 ypos 383
}
Grade {
 white {1 0.182036 0.000745 1}
 white_panelDropped true
 gamma {1 0.557589 0.301853 1}
 gamma_panelDropped true
 name Grade3
 xpos 4733
 ypos 421
}
Grade {
 white 2.8
 multiply 2.44
 name Grade4
 xpos 4733
 ypos 445
}
Saturation {
 saturation 0.59
 name Saturation3
 xpos 4733
 ypos 500
}
Dot {
 name Dot4
 xpos 4767
 ypos 560
}
set Naea51400 [stack 0]
Keyer {
 operation "luminance key"
 range {0 0.6105969537 1 1}
 name Keyer1
 xpos 4848
 ypos 551
}
Blur {
 size 19.5
 name Blur6
 xpos 4848
 ypos 587
}
set Naea51c00 [stack 0]
push $Naea51c00
push $Naea51400
Saturation {
 inputs 1+1
 saturation 0.74
 name Saturation2
 xpos 4733
 ypos 597
}
Grade {
 inputs 1+1
 white 1.08
 name Grade20
 xpos 4733
 ypos 621
}
Transform {
 scale {1 0.7}
 center {2048 2048}
 name Transform9
 xpos 4733
 ypos 645
}
Colorspace {
 colorspace_out HSV
 name Colorspace1
 xpos 4733
 ypos 669
}
Gamma {
 channels {-rgba.red -rgba.green rgba.blue none}
 value 0.54
 name Gamma1
 xpos 4733
 ypos 703
}
Colorspace {
 colorspace_in HSV
 name Colorspace2
 xpos 4733
 ypos 743
}
Crop {
 box {0 0 4096 4096}
 softness 53.4
 name Crop13
 xpos 4733
 ypos 767
}
Dot {
 name Dot5
 xpos 4767
 ypos 851
}
Roto {
 inputs 0
 output alpha
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097664}
    {t x44800000 x44428000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup OpenSpline1 1049088 bezier
     {{cc
       {f 1056800}
       {px x42680000
        {xc29c0000 xc3060000}
        {{a osw
       {{x42680000 1}}	 osf
       {{x42680000 0}}}     x434c0000 x43af0000}
        {x429c0000 x43060000}
        {xc3660000 xc3240000}
        {{a osw
       {{x42680000 1}}	 osf
       {{x42680000 0}}}     x43c50000 x44598000}
        {x43660000 x43240000}
        {xc2600000 x42880000}
        {{a osw
       {{x42680000 1}}	 osf
       {{x42680000 0}}}     x44518000 x44500000}
        {x42600000 xc2880000}
        {xc2b00000 x41400000}
        {{a osw
       {{x42680000 1}}	 osf
       {{x42680000 0}}}     x447b8000 x43ed0000}
        {x42b00000 xc1400000}
        {xc2780000 xc2200000}
        {{a osw
       {{x42680000 1}}	 osf
       {{x42680000 0}}}     x44bc0000 x43ef0000}
        {x42780000 x42200000}
        {xc1800000 xc0800000}
        {{a osw
       {{x42680000 1}}	 osf
       {{x42680000 0}}}     x44df0000 x4492c000}
        {x41800000 x40800000}}}     idem}
     {tx x42680000 x446ec000 x442e1555}
     {a osbe 0 osee 0 osw x41200000 osf 0 str 1 ltn x42680000 ltm x42680000 tt x41200000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createOpenSpline str 1 ssx 1 ssy 1 sf 1 tt 10 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {320 240}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 lifetime_start 58
 lifetime_end 58
 motionblur_shutter_offset_type centred
 name Roto30
 xpos 4603
 ypos 859
}
Group {
 inputs 2
 name CA_FlowWarp3
 tile_color 0x4c65ffff
 note_font "Verdana Bold"
 note_font_size 12
 note_font_color 0xe0cc30ff
 xpos 4733
 ypos 928
 addUserKnob {20 User}
 addUserKnob {41 format T BlinkScript.format}
 addUserKnob {26 d l " " T "Make sure format matches roto"}
 addUserKnob {26 ""}
 addUserKnob {22 SampleRoto l "Sample Roto" T "import nuke\nimport nuke.rotopaint as rp\n\n# Function to retrieve points from the Roto node's shapes and strokes\ndef get_roto_points(roto_node):\n    curves_knob = roto_node\['curves']\n    points = \[]\n    processed_elements = set()  # To track processed elements\n\n    # Access the root layer of the Roto node\n    root_layer = curves_knob.rootLayer\n\n    # Function to parse the layer and find shapes and strokes\n    def parse_layer(layer):\n        for element in layer:\n            element_id = id(element)  # Unique identifier for each element\n\n            # Check if the element is a Shape and not already processed\n            if isinstance(element, rp.Shape) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark element as processed\n\n                # Loop through the control points (CVs) in the shape\n                for point_idx, point in enumerate(element):\n                    frame = nuke.frame()\n                    # Get the position of the control vertex (center point)\n                    pos = point.center.getPosition(frame)\n                    points.append((pos\[0], pos\[1]))\n\n            # If the element is a Layer, process its contents\n            elif isinstance(element, rp.Layer) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark layer as processed\n                parse_layer(element)  # Recursively parse nested layers\n\n    # Parse the root layer to extract points\n    parse_layer(root_layer)\n    \n    return points\n\n# Main function to run the script and update the BlinkScript node\ndef main():\n    # Get the current node (the group node)\n    current_node = nuke.thisNode()\n\n    # Check if there is an input connected to the node (assuming input 0 is the roto node)\n    roto_node = current_node.input(0)\n    \n    if not roto_node or roto_node.Class() not in \['Roto', 'RotoPaint']:\n        nuke.message(\"Please connect a Roto or RotoPaint node to the current node.\")\n        return\n\n    # Get the points from the connected Roto or RotoPaint node\n    roto_points = get_roto_points(roto_node)\n    \n    if not roto_points:\n        nuke.message(\"No points found in the connected Roto node.\")\n        return\n    else:\n        # Begin the group to access internal nodes\n        current_node.begin()\n        # Find the BlinkScript node inside the group\n        blinkscript_node = None\n        blinkscript_node = nuke.toNode(current_node.name()+\".Dot_FW\").input(0)\n        \n        if blinkscript_node is None:\n            nuke.message(\"BlinkScript node not found inside the group.\")\n            current_node.end()\n            return\n\n        # Update the BlinkScript node parameters\n        # Set \"Number of Control Points\" to the number of points retrieved\n        blinkscript_node\['SplineUVMap_Number of Control Points'].setValue(len(roto_points))\n        # Update the positions of the points\n        max_points = 50  # Updated to support up to 50 points\n        for idx, point in enumerate(roto_points):\n            if idx >= max_points:\n                nuke.warning(f\"BlinkScript node supports a maximum of \{max_points\} points. Extra points are ignored.\")\n                break\n            # The point knobs are named \"SplineUVMap_Point0\", \"SplineUVMap_Point1\", etc.\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue(point)\n            else:\n                nuke.warning(f\"BlinkScript node does not have knob \{knob_name\}\")\n\n        # For any remaining Point knobs, set them to (0, 0)\n        for idx in range(len(roto_points), max_points):\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue((0.0, 0.0))\n\n        # End the group\n        current_node.end()\n\n# Execute the main function\nmain()" +STARTLINE}
 addUserKnob {41 "SplineUVMap_Number of Samples_1" l "Number of Samples" T "BlinkScript.SplineUVMap_Number of Samples"}
 addUserKnob {41 "SplineUVMap_Max Distance" l "Max Distance" T "BlinkScript.SplineUVMap_Max Distance"}
 addUserKnob {7 UVBLUR l "UV Blur" R 0 50}
 addUserKnob {41 "SplineUVMap_Curve Tightness" l "Curve Tightness" T "BlinkScript.SplineUVMap_Curve Tightness"}
 addUserKnob {41 "SplineUVMap_Normalize Samples" l "Normalize Samples" T "BlinkScript.SplineUVMap_Normalize Samples"}
 addUserKnob {26 explanation l Samples T "If you want your\nsamples evenly spread,\nnormalize them"}
 addUserKnob {26 ""}
 addUserKnob {41 "SplineUVMap_Number of Control Points" l "Number of Control Points" T "BlinkScript.SplineUVMap_Number of Control Points"}
 addUserKnob {26 _1 l Info: T "Auto detected from Sample Roto.  \nYou can put custom control points\nin group if you want."}
 addUserKnob {26 ""}
 addUserKnob {26 tapers l " " T "Taper Controls"}
 addUserKnob {41 "SplineUVMap_Width Start" l "Width Start" T "BlinkScript.SplineUVMap_Width Start"}
 addUserKnob {41 "SplineUVMap_Width Center" l "Width Center" T "BlinkScript.SplineUVMap_Width Center"}
 addUserKnob {41 "SplineUVMap_Width End" l "Width End" T "BlinkScript.SplineUVMap_Width End"}
 addUserKnob {26 ""}
 addUserKnob {26 Edge l "" -STARTLINE T "Edge Details"}
 addUserKnob {41 size l "Erode Edge" T FilterErode1.size}
 addUserKnob {41 filter l "Edge Filter" T FilterErode1.filter}
 addUserKnob {26 ""}
 addUserKnob {26 compacademy l " " T "For more:\nTools, Training, Epic Stock Footage:\n\nwww.compositingacademy.com\n\nMade in 2024"}
}
 BlinkScript {
  inputs 0
  recompileCount 2
  ProgramGroup 1
  KernelDescription "3 \"SplineUVMap\" iterate pixelWise 7323e521568e7c81daf69ed13b674e934e88cc6f9c6cb7a338b61e69790b719a 1 \"dst\" Write Point 58 \"Number of Control Points\" Int 1 BAAAAA== \"Number of Samples\" Int 1 ZAAAAA== \"Max Distance\" Float 1 AABIQg== \"Curve Tightness\" Float 1 AAAAAA== \"Width Start\" Float 1 AACAPw== \"Width Center\" Float 1 AACAPw== \"Width End\" Float 1 AACAPw== \"Normalize Samples\" Bool 1 AA== \"Point0\" Float 2 AAAAAAAAAAA= \"Point1\" Float 2 AAAAAAAAAAA= \"Point2\" Float 2 AAAAAAAAAAA= \"Point3\" Float 2 AAAAAAAAAAA= \"Point4\" Float 2 AAAAAAAAAAA= \"Point5\" Float 2 AAAAAAAAAAA= \"Point6\" Float 2 AAAAAAAAAAA= \"Point7\" Float 2 AAAAAAAAAAA= \"Point8\" Float 2 AAAAAAAAAAA= \"Point9\" Float 2 AAAAAAAAAAA= \"Point10\" Float 2 AAAAAAAAAAA= \"Point11\" Float 2 AAAAAAAAAAA= \"Point12\" Float 2 AAAAAAAAAAA= \"Point13\" Float 2 AAAAAAAAAAA= \"Point14\" Float 2 AAAAAAAAAAA= \"Point15\" Float 2 AAAAAAAAAAA= \"Point16\" Float 2 AAAAAAAAAAA= \"Point17\" Float 2 AAAAAAAAAAA= \"Point18\" Float 2 AAAAAAAAAAA= \"Point19\" Float 2 AAAAAAAAAAA= \"Point20\" Float 2 AAAAAAAAAAA= \"Point21\" Float 2 AAAAAAAAAAA= \"Point22\" Float 2 AAAAAAAAAAA= \"Point23\" Float 2 AAAAAAAAAAA= \"Point24\" Float 2 AAAAAAAAAAA= \"Point25\" Float 2 AAAAAAAAAAA= \"Point26\" Float 2 AAAAAAAAAAA= \"Point27\" Float 2 AAAAAAAAAAA= \"Point28\" Float 2 AAAAAAAAAAA= \"Point29\" Float 2 AAAAAAAAAAA= \"Point30\" Float 2 AAAAAAAAAAA= \"Point31\" Float 2 AAAAAAAAAAA= \"Point32\" Float 2 AAAAAAAAAAA= \"Point33\" Float 2 AAAAAAAAAAA= \"Point34\" Float 2 AAAAAAAAAAA= \"Point35\" Float 2 AAAAAAAAAAA= \"Point36\" Float 2 AAAAAAAAAAA= \"Point37\" Float 2 AAAAAAAAAAA= \"Point38\" Float 2 AAAAAAAAAAA= \"Point39\" Float 2 AAAAAAAAAAA= \"Point40\" Float 2 AAAAAAAAAAA= \"Point41\" Float 2 AAAAAAAAAAA= \"Point42\" Float 2 AAAAAAAAAAA= \"Point43\" Float 2 AAAAAAAAAAA= \"Point44\" Float 2 AAAAAAAAAAA= \"Point45\" Float 2 AAAAAAAAAAA= \"Point46\" Float 2 AAAAAAAAAAA= \"Point47\" Float 2 AAAAAAAAAAA= \"Point48\" Float 2 AAAAAAAAAAA= \"Point49\" Float 2 AAAAAAAAAAA= 58 \"numControlPoints\" 1 1 Default \"numSamples\" 1 1 Default \"maxDistance\" 1 1 Default \"tightness\" 1 1 Default \"widthStart\" 1 1 Default \"widthCenter\" 1 1 Default \"widthEnd\" 1 1 Default \"normalizeSamples\" 1 1 Default \"Point0\" 2 1 Default \"Point1\" 2 1 Default \"Point2\" 2 1 Default \"Point3\" 2 1 Default \"Point4\" 2 1 Default \"Point5\" 2 1 Default \"Point6\" 2 1 Default \"Point7\" 2 1 Default \"Point8\" 2 1 Default \"Point9\" 2 1 Default \"Point10\" 2 1 Default \"Point11\" 2 1 Default \"Point12\" 2 1 Default \"Point13\" 2 1 Default \"Point14\" 2 1 Default \"Point15\" 2 1 Default \"Point16\" 2 1 Default \"Point17\" 2 1 Default \"Point18\" 2 1 Default \"Point19\" 2 1 Default \"Point20\" 2 1 Default \"Point21\" 2 1 Default \"Point22\" 2 1 Default \"Point23\" 2 1 Default \"Point24\" 2 1 Default \"Point25\" 2 1 Default \"Point26\" 2 1 Default \"Point27\" 2 1 Default \"Point28\" 2 1 Default \"Point29\" 2 1 Default \"Point30\" 2 1 Default \"Point31\" 2 1 Default \"Point32\" 2 1 Default \"Point33\" 2 1 Default \"Point34\" 2 1 Default \"Point35\" 2 1 Default \"Point36\" 2 1 Default \"Point37\" 2 1 Default \"Point38\" 2 1 Default \"Point39\" 2 1 Default \"Point40\" 2 1 Default \"Point41\" 2 1 Default \"Point42\" 2 1 Default \"Point43\" 2 1 Default \"Point44\" 2 1 Default \"Point45\" 2 1 Default \"Point46\" 2 1 Default \"Point47\" 2 1 Default \"Point48\" 2 1 Default \"Point49\" 2 1 Default 0"
  kernelSource "kernel SplineUVMap : ImageComputationKernel<ePixelWise>\n\{\n  Image<eWrite> dst;\n\n  param:\n    int numControlPoints;\n    int numSamples;\n    float maxDistance;\n    float tightness;\n    float widthStart;\n    float widthCenter;\n    float widthEnd;\n    bool normalizeSamples;\n\n    // Define control points up to the maximum allowed (50 points)\n    float2 Point0;\n    float2 Point1;\n    float2 Point2;\n    float2 Point3;\n    float2 Point4;\n    float2 Point5;\n    float2 Point6;\n    float2 Point7;\n    float2 Point8;\n    float2 Point9;\n    float2 Point10;\n    float2 Point11;\n    float2 Point12;\n    float2 Point13;\n    float2 Point14;\n    float2 Point15;\n    float2 Point16;\n    float2 Point17;\n    float2 Point18;\n    float2 Point19;\n    float2 Point20;\n    float2 Point21;\n    float2 Point22;\n    float2 Point23;\n    float2 Point24;\n    float2 Point25;\n    float2 Point26;\n    float2 Point27;\n    float2 Point28;\n    float2 Point29;\n    float2 Point30;\n    float2 Point31;\n    float2 Point32;\n    float2 Point33;\n    float2 Point34;\n    float2 Point35;\n    float2 Point36;\n    float2 Point37;\n    float2 Point38;\n    float2 Point39;\n    float2 Point40;\n    float2 Point41;\n    float2 Point42;\n    float2 Point43;\n    float2 Point44;\n    float2 Point45;\n    float2 Point46;\n    float2 Point47;\n    float2 Point48;\n    float2 Point49;\n\n  void define()\n  \{\n    defineParam(numControlPoints, \"Number of Control Points\", 4);\n    defineParam(numSamples, \"Number of Samples\", 100);\n    defineParam(maxDistance, \"Max Distance\", 50.0f);\n    defineParam(tightness, \"Curve Tightness\", 0.0f); // 0 = smooth, 1 = linear\n    defineParam(widthStart, \"Width Start\", 1.0f);\n    defineParam(widthCenter, \"Width Center\", 1.0f);\n    defineParam(widthEnd, \"Width End\", 1.0f);\n    defineParam(normalizeSamples, \"Normalize Samples\", false);\n\n    // Define each control point parameter\n    defineParam(Point0, \"Point0\", float2(0.0f, 0.0f));\n    defineParam(Point1, \"Point1\", float2(0.0f, 0.0f));\n    defineParam(Point2, \"Point2\", float2(0.0f, 0.0f));\n    defineParam(Point3, \"Point3\", float2(0.0f, 0.0f));\n    defineParam(Point4, \"Point4\", float2(0.0f, 0.0f));\n    defineParam(Point5, \"Point5\", float2(0.0f, 0.0f));\n    defineParam(Point6, \"Point6\", float2(0.0f, 0.0f));\n    defineParam(Point7, \"Point7\", float2(0.0f, 0.0f));\n    defineParam(Point8, \"Point8\", float2(0.0f, 0.0f));\n    defineParam(Point9, \"Point9\", float2(0.0f, 0.0f));\n    defineParam(Point10, \"Point10\", float2(0.0f, 0.0f));\n    defineParam(Point11, \"Point11\", float2(0.0f, 0.0f));\n    defineParam(Point12, \"Point12\", float2(0.0f, 0.0f));\n    defineParam(Point13, \"Point13\", float2(0.0f, 0.0f));\n    defineParam(Point14, \"Point14\", float2(0.0f, 0.0f));\n    defineParam(Point15, \"Point15\", float2(0.0f, 0.0f));\n    defineParam(Point16, \"Point16\", float2(0.0f, 0.0f));\n    defineParam(Point17, \"Point17\", float2(0.0f, 0.0f));\n    defineParam(Point18, \"Point18\", float2(0.0f, 0.0f));\n    defineParam(Point19, \"Point19\", float2(0.0f, 0.0f));\n    defineParam(Point20, \"Point20\", float2(0.0f, 0.0f));\n    defineParam(Point21, \"Point21\", float2(0.0f, 0.0f));\n    defineParam(Point22, \"Point22\", float2(0.0f, 0.0f));\n    defineParam(Point23, \"Point23\", float2(0.0f, 0.0f));\n    defineParam(Point24, \"Point24\", float2(0.0f, 0.0f));\n    defineParam(Point25, \"Point25\", float2(0.0f, 0.0f));\n    defineParam(Point26, \"Point26\", float2(0.0f, 0.0f));\n    defineParam(Point27, \"Point27\", float2(0.0f, 0.0f));\n    defineParam(Point28, \"Point28\", float2(0.0f, 0.0f));\n    defineParam(Point29, \"Point29\", float2(0.0f, 0.0f));\n    defineParam(Point30, \"Point30\", float2(0.0f, 0.0f));\n    defineParam(Point31, \"Point31\", float2(0.0f, 0.0f));\n    defineParam(Point32, \"Point32\", float2(0.0f, 0.0f));\n    defineParam(Point33, \"Point33\", float2(0.0f, 0.0f));\n    defineParam(Point34, \"Point34\", float2(0.0f, 0.0f));\n    defineParam(Point35, \"Point35\", float2(0.0f, 0.0f));\n    defineParam(Point36, \"Point36\", float2(0.0f, 0.0f));\n    defineParam(Point37, \"Point37\", float2(0.0f, 0.0f));\n    defineParam(Point38, \"Point38\", float2(0.0f, 0.0f));\n    defineParam(Point39, \"Point39\", float2(0.0f, 0.0f));\n    defineParam(Point40, \"Point40\", float2(0.0f, 0.0f));\n    defineParam(Point41, \"Point41\", float2(0.0f, 0.0f));\n    defineParam(Point42, \"Point42\", float2(0.0f, 0.0f));\n    defineParam(Point43, \"Point43\", float2(0.0f, 0.0f));\n    defineParam(Point44, \"Point44\", float2(0.0f, 0.0f));\n    defineParam(Point45, \"Point45\", float2(0.0f, 0.0f));\n    defineParam(Point46, \"Point46\", float2(0.0f, 0.0f));\n    defineParam(Point47, \"Point47\", float2(0.0f, 0.0f));\n    defineParam(Point48, \"Point48\", float2(0.0f, 0.0f));\n    defineParam(Point49, \"Point49\", float2(0.0f, 0.0f));\n  \}\n\n  float dot2(float2 a, float2 b) \{\n    return a.x * b.x + a.y * b.y;\n  \}\n\n  float length2(float2 v) \{\n    return sqrt(v.x * v.x + v.y * v.y);\n  \}\n\n  float2 normalize2(float2 v) \{\n    float len = length2(v);\n    if (len > 0.0f) \{\n      return float2(v.x / len, v.y / len);\n    \} else \{\n      return float2(0.0f, 0.0f);\n    \}\n  \}\n\n  float2 evaluateSpline(float t)\n  \{\n    int numSegments = numControlPoints - 1;\n    float totalLength = (float)(numSegments);\n    float scaledT = t * totalLength;\n    int segment = (int)(floor(scaledT));\n    if (segment >= numSegments)\n      segment = numSegments - 1;\n    float localT = scaledT - (float)(segment);\n\n    int p0 = max(segment - 1, 0);\n    int p1 = segment;\n    int p2 = min(segment + 1, numControlPoints - 1);\n    int p3 = min(segment + 2, numControlPoints - 1);\n\n    float2 CP\[50];\n    CP\[0] = Point0;\n    CP\[1] = Point1;\n    CP\[2] = Point2;\n    CP\[3] = Point3;\n    CP\[4] = Point4;\n    CP\[5] = Point5;\n    CP\[6] = Point6;\n    CP\[7] = Point7;\n    CP\[8] = Point8;\n    CP\[9] = Point9;\n    CP\[10] = Point10;\n    CP\[11] = Point11;\n    CP\[12] = Point12;\n    CP\[13] = Point13;\n    CP\[14] = Point14;\n    CP\[15] = Point15;\n    CP\[16] = Point16;\n    CP\[17] = Point17;\n    CP\[18] = Point18;\n    CP\[19] = Point19;\n    CP\[20] = Point20;\n    CP\[21] = Point21;\n    CP\[22] = Point22;\n    CP\[23] = Point23;\n    CP\[24] = Point24;\n    CP\[25] = Point25;\n    CP\[26] = Point26;\n    CP\[27] = Point27;\n    CP\[28] = Point28;\n    CP\[29] = Point29;\n    CP\[30] = Point30;\n    CP\[31] = Point31;\n    CP\[32] = Point32;\n    CP\[33] = Point33;\n    CP\[34] = Point34;\n    CP\[35] = Point35;\n    CP\[36] = Point36;\n    CP\[37] = Point37;\n    CP\[38] = Point38;\n    CP\[39] = Point39;\n    CP\[40] = Point40;\n    CP\[41] = Point41;\n    CP\[42] = Point42;\n    CP\[43] = Point43;\n    CP\[44] = Point44;\n    CP\[45] = Point45;\n    CP\[46] = Point46;\n    CP\[47] = Point47;\n    CP\[48] = Point48;\n    CP\[49] = Point49;\n\n    float2 P0 = CP\[p0];\n    float2 P1 = CP\[p1];\n    float2 P2 = CP\[p2];\n    float2 P3 = CP\[p3];\n\n    // Linear interpolation\n    float2 linear = P1 + (P2 - P1) * localT;\n\n    // Catmull-Rom spline interpolation\n    float2 catmullRom = 0.5f * (\n      (2.0f * P1) +\n      (-P0 + P2) * localT +\n      (2.0f * P0 - 5.0f * P1 + 4.0f * P2 - P3) * localT * localT +\n      (-P0 + 3.0f * P1 - 3.0f * P2 + P3) * localT * localT * localT\n    );\n\n    // Interpolate between linear and Catmull-Rom based on tightness\n    return linear * tightness + catmullRom * (1.0f - tightness);\n  \}\n\n  float2 tangentSpline(float t)\n  \{\n    int numSegments = numControlPoints - 1;\n    float totalLength = (float)(numSegments);\n    float scaledT = t * totalLength;\n    int segment = (int)(floor(scaledT));\n    if (segment >= numSegments)\n      segment = numSegments - 1;\n    float localT = scaledT - (float)(segment);\n\n    int p0 = max(segment - 1, 0);\n    int p1 = segment;\n    int p2 = min(segment + 1, numControlPoints - 1);\n    int p3 = min(segment + 2, numControlPoints - 1);\n\n    float2 CP\[50];\n    CP\[0] = Point0;\n    CP\[1] = Point1;\n    CP\[2] = Point2;\n    CP\[3] = Point3;\n    CP\[4] = Point4;\n    CP\[5] = Point5;\n    CP\[6] = Point6;\n    CP\[7] = Point7;\n    CP\[8] = Point8;\n    CP\[9] = Point9;\n    CP\[10] = Point10;\n    CP\[11] = Point11;\n    CP\[12] = Point12;\n    CP\[13] = Point13;\n    CP\[14] = Point14;\n    CP\[15] = Point15;\n    CP\[16] = Point16;\n    CP\[17] = Point17;\n    CP\[18] = Point18;\n    CP\[19] = Point19;\n    CP\[20] = Point20;\n    CP\[21] = Point21;\n    CP\[22] = Point22;\n    CP\[23] = Point23;\n    CP\[24] = Point24;\n    CP\[25] = Point25;\n    CP\[26] = Point26;\n    CP\[27] = Point27;\n    CP\[28] = Point28;\n    CP\[29] = Point29;\n    CP\[30] = Point30;\n    CP\[31] = Point31;\n    CP\[32] = Point32;\n    CP\[33] = Point33;\n    CP\[34] = Point34;\n    CP\[35] = Point35;\n    CP\[36] = Point36;\n    CP\[37] = Point37;\n    CP\[38] = Point38;\n    CP\[39] = Point39;\n    CP\[40] = Point40;\n    CP\[41] = Point41;\n    CP\[42] = Point42;\n    CP\[43] = Point43;\n    CP\[44] = Point44;\n    CP\[45] = Point45;\n    CP\[46] = Point46;\n    CP\[47] = Point47;\n    CP\[48] = Point48;\n    CP\[49] = Point49;\n\n    float2 P0 = CP\[p0];\n    float2 P1 = CP\[p1];\n    float2 P2 = CP\[p2];\n    float2 P3 = CP\[p3];\n\n    // Linear tangent\n    float2 linearTangent = P2 - P1;\n// Catmull-Rom tangent (continued)\n    float2 catmullRomTangent = 0.5f * (\n      (-P0 + P2) +\n      2.0f * (2.0f * P0 - 5.0f * P1 + 4.0f * P2 - P3) * localT +\n      3.0f * (-P0 + 3.0f * P1 - 3.0f * P2 + P3) * localT * localT\n    );\n\n    // Interpolate between linear and Catmull-Rom tangents based on tightness\n    return normalize2(linearTangent * tightness + catmullRomTangent * (1.0f - tightness));\n  \}\n\n  float getWidth(float t)\n  \{\n    if (t < 0.5f) \{\n      return widthStart + (widthCenter - widthStart) * (t * 2.0f);\n    \} else \{\n      return widthCenter + (widthEnd - widthCenter) * ((t - 0.5f) * 2.0f);\n    \}\n  \}\n\n  float normalizedSamplePosition(int sampleIndex)\n  \{\n    if (!normalizeSamples) \{\n      return (float)sampleIndex / (float)numSamples;\n    \}\n\n    float totalLength = 0.0f;\n    float segmentLengths\[50];\n    int numSegments = numControlPoints - 1;\n\n    for (int i = 0; i < numSegments; ++i) \{\n      float2 p1 = evaluateSpline((float)i / (float)numSegments);\n      float2 p2 = evaluateSpline((float)(i + 1) / (float)numSegments);\n      float segmentLength = length2(p2 - p1);\n      segmentLengths\[i] = segmentLength;\n      totalLength += segmentLength;\n    \}\n\n    float targetLength = totalLength * (float)sampleIndex / (float)numSamples;\n    float currentLength = 0.0f;\n\n    for (int i = 0; i < numSegments; ++i) \{\n      if (currentLength + segmentLengths\[i] >= targetLength) \{\n        float segmentT = (targetLength - currentLength) / segmentLengths\[i];\n        return ((float)i + segmentT) / (float)numSegments;\n      \}\n      currentLength += segmentLengths\[i];\n    \}\n\n    return 1.0f;\n  \}\n\n  void process(int2 pos)\n  \{\n    float2 pixelPos = float2((float)(pos.x), (float)(pos.y));\n\n    float minDistSq = 1e10f;\n    float closest_t = 0.0f;\n    float2 closestPoint = pixelPos;\n    float2 closestTangent = float2(0.0f, 0.0f);\n\n    for (int i = 0; i <= numSamples; ++i)\n    \{\n      float t = normalizedSamplePosition(i);\n\n      float2 S_t = evaluateSpline(t);\n      float2 tangent = tangentSpline(t);\n\n      float2 diff = pixelPos - S_t;\n      float distSq = dot2(diff, diff);\n\n      if (distSq < minDistSq)\n      \{\n        minDistSq = distSq;\n        closestPoint = S_t;\n        closestTangent = tangent;\n        closest_t = t;\n      \}\n    \}\n\n    float dist = sqrt(minDistSq);\n    float width = getWidth(closest_t);\n\n    if (dist <= maxDistance * width)\n    \{\n      float U = closest_t;\n\n      float2 normal = float2(-closestTangent.y, closestTangent.x);\n      normal = normalize2(normal);\n\n      float side = dot2(pixelPos - closestPoint, normal);\n      float V = side / (maxDistance * width) * 0.5f + 0.5f; // Normalize V to \[0,1]\n\n      dst() = float4(U, V, 0.0f, 1.0f);\n    \}\n    else\n    \{\n      dst() = float4(0.0f, 0.0f, 0.0f, 0.0f);\n    \}\n  \}\n\};"
  rebuild ""
  "SplineUVMap_Number of Control Points" 6
  "SplineUVMap_Number of Samples" 400
  "SplineUVMap_Max Distance" 55
  "SplineUVMap_Width Start" 55
  "SplineUVMap_Width Center" 70
  "SplineUVMap_Width End" 55
  SplineUVMap_Point0 {204 350}
  SplineUVMap_Point1 {394 870}
  SplineUVMap_Point2 {838 832}
  SplineUVMap_Point3 {1006 474}
  SplineUVMap_Point4 {1504 478}
  SplineUVMap_Point5 {1784 1174}
  specifiedFormat true
  rebuild_finalise ""
  name BlinkScript
  selected true
  xpos 656
  ypos 25
 }
 Dot {
  name Dot_FW
  label "this dot is used to locate the Blinkscript"
  note_font_size 10
  xpos 690
  ypos 84
 }
set Na45a2800 [stack 0]
 Dot {
  name Dot10
  xpos 846
  ypos 147
 }
 FilterErode {
  size 0
  filter gaussian
  name FilterErode1
  xpos 812
  ypos 258
 }
push $Na45a2800
 Blur {
  size {{parent.UVBLUR}}
  name Blur1
  xpos 656
  ypos 122
 }
 Input {
  inputs 0
  name Image
  xpos 455
  ypos 168
  number 1
 }
 STMap {
  inputs 2
  uv rgb
  name STMap2
  xpos 656
  ypos 207
 }
 Merge2 {
  inputs 2
  operation mask
  name Merge1
  xpos 656
  ypos 264
 }
 Output {
  name Output1
  xpos 656
  ypos 308
 }
 Input {
  inputs 0
  name Roto
  xpos 987
  ypos 199
 }
end_group
ColorWheel {
 inputs 0
 gamma 0.45
 name ColorWheel1
 xpos 1657
 ypos 315
}
Transform {
 scale {0.1 1}
 center {1024 778}
 name Transform1
 xpos 1657
 ypos 483
}
Roto {
 inputs 0
 output alpha
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097152}
    {t x44800000 x44428000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup OpenSpline1 1049088 bezier
     {{cc
       {f 1056800}
       {px x43340000
        {xc0e00000 xc2940000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x42a60000 x44138000}
        {x40e00000 x42940000}
        {xc1f80000 xc29a0000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x42fa0000 x446d0000}
        {x41f80000 x429a0000}
        {xc2820000 xc1a00000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x43bb8000 x4491e000}
        {x42820000 x41a00000}
        {xc1400000 x41b80000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44220000 x4480a000}
        {x41400000 xc1b80000}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x442c8000 x441e4000}
        {0 0}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x444d4000 x43f18000}
        {0 0}
        {0 xc1d80000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44710000 x43e00000}
        {0 x41d80000}
        {xc0800000 xc1d80000}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44840000 x44250000}
        {x40800000 x41d80000}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x449c0000 x4476c000}
        {0 0}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44b68000 x4487e000}
        {0 0}
        {0 0}
        {{a osw
       {{x43340000 1}}	 osf
       {{x43340000 0}}}     x44dfe000 x4481a000}
        {0 0}}}     idem}
     {tx x43340000 x44527a2f x444e1d17}
     {a osbe 0 osee 0 osw x41200000 osf 0 str 1 ltn x43340000 ltm x43340000 tt x41200000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createOpenSpline str 1 ssx 1 ssy 1 sf 1 tt 10 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {320 240}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 lifetime_start 180
 lifetime_end 180
 motionblur_shutter_offset_type centred
 name Roto1
 xpos 1220
 ypos 311
}
Group {
 inputs 2
 name CA_FlowWarp1
 tile_color 0x4c65ffff
 note_font "Verdana Bold"
 note_font_size 12
 note_font_color 0xe0cc30ff
 xpos 1220
 ypos 474
 addUserKnob {20 User}
 addUserKnob {41 format T BlinkScript.format}
 addUserKnob {26 d l " " T "Make sure format matches roto"}
 addUserKnob {26 ""}
 addUserKnob {22 SampleRoto l "Sample Roto" T "import nuke\nimport nuke.rotopaint as rp\n\n# Function to retrieve points from the Roto node's shapes and strokes\ndef get_roto_points(roto_node):\n    curves_knob = roto_node\['curves']\n    points = \[]\n    processed_elements = set()  # To track processed elements\n\n    # Access the root layer of the Roto node\n    root_layer = curves_knob.rootLayer\n\n    # Function to parse the layer and find shapes and strokes\n    def parse_layer(layer):\n        for element in layer:\n            element_id = id(element)  # Unique identifier for each element\n\n            # Check if the element is a Shape and not already processed\n            if isinstance(element, rp.Shape) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark element as processed\n\n                # Loop through the control points (CVs) in the shape\n                for point_idx, point in enumerate(element):\n                    frame = nuke.frame()\n                    # Get the position of the control vertex (center point)\n                    pos = point.center.getPosition(frame)\n                    points.append((pos\[0], pos\[1]))\n\n            # If the element is a Layer, process its contents\n            elif isinstance(element, rp.Layer) and element_id not in processed_elements:\n                processed_elements.add(element_id)  # Mark layer as processed\n                parse_layer(element)  # Recursively parse nested layers\n\n    # Parse the root layer to extract points\n    parse_layer(root_layer)\n    \n    return points\n\n# Main function to run the script and update the BlinkScript node\ndef main():\n    # Get the current node (the group node)\n    current_node = nuke.thisNode()\n\n    # Check if there is an input connected to the node (assuming input 0 is the roto node)\n    roto_node = current_node.input(0)\n    \n    if not roto_node or roto_node.Class() not in \['Roto', 'RotoPaint']:\n        nuke.message(\"Please connect a Roto or RotoPaint node to the current node.\")\n        return\n\n    # Get the points from the connected Roto or RotoPaint node\n    roto_points = get_roto_points(roto_node)\n    \n    if not roto_points:\n        nuke.message(\"No points found in the connected Roto node.\")\n        return\n    else:\n        # Begin the group to access internal nodes\n        current_node.begin()\n        # Find the BlinkScript node inside the group\n        blinkscript_node = None\n        blinkscript_node = nuke.toNode(current_node.name()+\".Dot_FW\").input(0)\n        \n        if blinkscript_node is None:\n            nuke.message(\"BlinkScript node not found inside the group.\")\n            current_node.end()\n            return\n\n        # Update the BlinkScript node parameters\n        # Set \"Number of Control Points\" to the number of points retrieved\n        blinkscript_node\['SplineUVMap_Number of Control Points'].setValue(len(roto_points))\n        # Update the positions of the points\n        max_points = 50  # Updated to support up to 50 points\n        for idx, point in enumerate(roto_points):\n            if idx >= max_points:\n                nuke.warning(f\"BlinkScript node supports a maximum of \{max_points\} points. Extra points are ignored.\")\n                break\n            # The point knobs are named \"SplineUVMap_Point0\", \"SplineUVMap_Point1\", etc.\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue(point)\n            else:\n                nuke.warning(f\"BlinkScript node does not have knob \{knob_name\}\")\n\n        # For any remaining Point knobs, set them to (0, 0)\n        for idx in range(len(roto_points), max_points):\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue((0.0, 0.0))\n\n        # End the group\n        current_node.end()\n\n# Execute the main function\nmain()" +STARTLINE}
 addUserKnob {41 "SplineUVMap_Number of Samples_1" l "Number of Samples" T "BlinkScript.SplineUVMap_Number of Samples"}
 addUserKnob {41 "SplineUVMap_Max Distance" l "Max Distance" T "BlinkScript.SplineUVMap_Max Distance"}
 addUserKnob {7 UVBLUR l "UV Blur" R 0 50}
 addUserKnob {41 "SplineUVMap_Curve Tightness" l "Curve Tightness" T "BlinkScript.SplineUVMap_Curve Tightness"}
 addUserKnob {41 "SplineUVMap_Normalize Samples" l "Normalize Samples" T "BlinkScript.SplineUVMap_Normalize Samples"}
 addUserKnob {26 explanation l Samples T "If you want your\nsamples evenly spread,\nnormalize them"}
 addUserKnob {26 ""}
 addUserKnob {41 "SplineUVMap_Number of Control Points" l "Number of Control Points" T "BlinkScript.SplineUVMap_Number of Control Points"}
 addUserKnob {26 _1 l Info: T "Auto detected from Sample Roto.  \nYou can put custom control points\nin group if you want."}
 addUserKnob {26 ""}
 addUserKnob {26 tapers l " " T "Taper Controls"}
 addUserKnob {41 "SplineUVMap_Width Start" l "Width Start" T "BlinkScript.SplineUVMap_Width Start"}
 addUserKnob {41 "SplineUVMap_Width Center" l "Width Center" T "BlinkScript.SplineUVMap_Width Center"}
 addUserKnob {41 "SplineUVMap_Width End" l "Width End" T "BlinkScript.SplineUVMap_Width End"}
 addUserKnob {26 ""}
 addUserKnob {26 Edge l "" -STARTLINE T "Edge Details"}
 addUserKnob {41 size l "Erode Edge" T FilterErode1.size}
 addUserKnob {41 filter l "Edge Filter" T FilterErode1.filter}
 addUserKnob {26 ""}
 addUserKnob {26 compacademy l " " T "For more:\nTools, Training, Epic Stock Footage:\n\nwww.compositingacademy.com\n\nMade in 2024"}
}
 BlinkScript {
  inputs 0
  recompileCount 2
  ProgramGroup 1
  KernelDescription "3 \"SplineUVMap\" iterate pixelWise 7323e521568e7c81daf69ed13b674e934e88cc6f9c6cb7a338b61e69790b719a 1 \"dst\" Write Point 58 \"Number of Control Points\" Int 1 BAAAAA== \"Number of Samples\" Int 1 ZAAAAA== \"Max Distance\" Float 1 AABIQg== \"Curve Tightness\" Float 1 AAAAAA== \"Width Start\" Float 1 AACAPw== \"Width Center\" Float 1 AACAPw== \"Width End\" Float 1 AACAPw== \"Normalize Samples\" Bool 1 AA== \"Point0\" Float 2 AAAAAAAAAAA= \"Point1\" Float 2 AAAAAAAAAAA= \"Point2\" Float 2 AAAAAAAAAAA= \"Point3\" Float 2 AAAAAAAAAAA= \"Point4\" Float 2 AAAAAAAAAAA= \"Point5\" Float 2 AAAAAAAAAAA= \"Point6\" Float 2 AAAAAAAAAAA= \"Point7\" Float 2 AAAAAAAAAAA= \"Point8\" Float 2 AAAAAAAAAAA= \"Point9\" Float 2 AAAAAAAAAAA= \"Point10\" Float 2 AAAAAAAAAAA= \"Point11\" Float 2 AAAAAAAAAAA= \"Point12\" Float 2 AAAAAAAAAAA= \"Point13\" Float 2 AAAAAAAAAAA= \"Point14\" Float 2 AAAAAAAAAAA= \"Point15\" Float 2 AAAAAAAAAAA= \"Point16\" Float 2 AAAAAAAAAAA= \"Point17\" Float 2 AAAAAAAAAAA= \"Point18\" Float 2 AAAAAAAAAAA= \"Point19\" Float 2 AAAAAAAAAAA= \"Point20\" Float 2 AAAAAAAAAAA= \"Point21\" Float 2 AAAAAAAAAAA= \"Point22\" Float 2 AAAAAAAAAAA= \"Point23\" Float 2 AAAAAAAAAAA= \"Point24\" Float 2 AAAAAAAAAAA= \"Point25\" Float 2 AAAAAAAAAAA= \"Point26\" Float 2 AAAAAAAAAAA= \"Point27\" Float 2 AAAAAAAAAAA= \"Point28\" Float 2 AAAAAAAAAAA= \"Point29\" Float 2 AAAAAAAAAAA= \"Point30\" Float 2 AAAAAAAAAAA= \"Point31\" Float 2 AAAAAAAAAAA= \"Point32\" Float 2 AAAAAAAAAAA= \"Point33\" Float 2 AAAAAAAAAAA= \"Point34\" Float 2 AAAAAAAAAAA= \"Point35\" Float 2 AAAAAAAAAAA= \"Point36\" Float 2 AAAAAAAAAAA= \"Point37\" Float 2 AAAAAAAAAAA= \"Point38\" Float 2 AAAAAAAAAAA= \"Point39\" Float 2 AAAAAAAAAAA= \"Point40\" Float 2 AAAAAAAAAAA= \"Point41\" Float 2 AAAAAAAAAAA= \"Point42\" Float 2 AAAAAAAAAAA= \"Point43\" Float 2 AAAAAAAAAAA= \"Point44\" Float 2 AAAAAAAAAAA= \"Point45\" Float 2 AAAAAAAAAAA= \"Point46\" Float 2 AAAAAAAAAAA= \"Point47\" Float 2 AAAAAAAAAAA= \"Point48\" Float 2 AAAAAAAAAAA= \"Point49\" Float 2 AAAAAAAAAAA= 58 \"numControlPoints\" 1 1 Default \"numSamples\" 1 1 Default \"maxDistance\" 1 1 Default \"tightness\" 1 1 Default \"widthStart\" 1 1 Default \"widthCenter\" 1 1 Default \"widthEnd\" 1 1 Default \"normalizeSamples\" 1 1 Default \"Point0\" 2 1 Default \"Point1\" 2 1 Default \"Point2\" 2 1 Default \"Point3\" 2 1 Default \"Point4\" 2 1 Default \"Point5\" 2 1 Default \"Point6\" 2 1 Default \"Point7\" 2 1 Default \"Point8\" 2 1 Default \"Point9\" 2 1 Default \"Point10\" 2 1 Default \"Point11\" 2 1 Default \"Point12\" 2 1 Default \"Point13\" 2 1 Default \"Point14\" 2 1 Default \"Point15\" 2 1 Default \"Point16\" 2 1 Default \"Point17\" 2 1 Default \"Point18\" 2 1 Default \"Point19\" 2 1 Default \"Point20\" 2 1 Default \"Point21\" 2 1 Default \"Point22\" 2 1 Default \"Point23\" 2 1 Default \"Point24\" 2 1 Default \"Point25\" 2 1 Default \"Point26\" 2 1 Default \"Point27\" 2 1 Default \"Point28\" 2 1 Default \"Point29\" 2 1 Default \"Point30\" 2 1 Default \"Point31\" 2 1 Default \"Point32\" 2 1 Default \"Point33\" 2 1 Default \"Point34\" 2 1 Default \"Point35\" 2 1 Default \"Point36\" 2 1 Default \"Point37\" 2 1 Default \"Point38\" 2 1 Default \"Point39\" 2 1 Default \"Point40\" 2 1 Default \"Point41\" 2 1 Default \"Point42\" 2 1 Default \"Point43\" 2 1 Default \"Point44\" 2 1 Default \"Point45\" 2 1 Default \"Point46\" 2 1 Default \"Point47\" 2 1 Default \"Point48\" 2 1 Default \"Point49\" 2 1 Default 0"
  kernelSource "kernel SplineUVMap : ImageComputationKernel<ePixelWise>\n\{\n  Image<eWrite> dst;\n\n  param:\n    int numControlPoints;\n    int numSamples;\n    float maxDistance;\n    float tightness;\n    float widthStart;\n    float widthCenter;\n    float widthEnd;\n    bool normalizeSamples;\n\n    // Define control points up to the maximum allowed (50 points)\n    float2 Point0;\n    float2 Point1;\n    float2 Point2;\n    float2 Point3;\n    float2 Point4;\n    float2 Point5;\n    float2 Point6;\n    float2 Point7;\n    float2 Point8;\n    float2 Point9;\n    float2 Point10;\n    float2 Point11;\n    float2 Point12;\n    float2 Point13;\n    float2 Point14;\n    float2 Point15;\n    float2 Point16;\n    float2 Point17;\n    float2 Point18;\n    float2 Point19;\n    float2 Point20;\n    float2 Point21;\n    float2 Point22;\n    float2 Point23;\n    float2 Point24;\n    float2 Point25;\n    float2 Point26;\n    float2 Point27;\n    float2 Point28;\n    float2 Point29;\n    float2 Point30;\n    float2 Point31;\n    float2 Point32;\n    float2 Point33;\n    float2 Point34;\n    float2 Point35;\n    float2 Point36;\n    float2 Point37;\n    float2 Point38;\n    float2 Point39;\n    float2 Point40;\n    float2 Point41;\n    float2 Point42;\n    float2 Point43;\n    float2 Point44;\n    float2 Point45;\n    float2 Point46;\n    float2 Point47;\n    float2 Point48;\n    float2 Point49;\n\n  void define()\n  \{\n    defineParam(numControlPoints, \"Number of Control Points\", 4);\n    defineParam(numSamples, \"Number of Samples\", 100);\n    defineParam(maxDistance, \"Max Distance\", 50.0f);\n    defineParam(tightness, \"Curve Tightness\", 0.0f); // 0 = smooth, 1 = linear\n    defineParam(widthStart, \"Width Start\", 1.0f);\n    defineParam(widthCenter, \"Width Center\", 1.0f);\n    defineParam(widthEnd, \"Width End\", 1.0f);\n    defineParam(normalizeSamples, \"Normalize Samples\", false);\n\n    // Define each control point parameter\n    defineParam(Point0, \"Point0\", float2(0.0f, 0.0f));\n    defineParam(Point1, \"Point1\", float2(0.0f, 0.0f));\n    defineParam(Point2, \"Point2\", float2(0.0f, 0.0f));\n    defineParam(Point3, \"Point3\", float2(0.0f, 0.0f));\n    defineParam(Point4, \"Point4\", float2(0.0f, 0.0f));\n    defineParam(Point5, \"Point5\", float2(0.0f, 0.0f));\n    defineParam(Point6, \"Point6\", float2(0.0f, 0.0f));\n    defineParam(Point7, \"Point7\", float2(0.0f, 0.0f));\n    defineParam(Point8, \"Point8\", float2(0.0f, 0.0f));\n    defineParam(Point9, \"Point9\", float2(0.0f, 0.0f));\n    defineParam(Point10, \"Point10\", float2(0.0f, 0.0f));\n    defineParam(Point11, \"Point11\", float2(0.0f, 0.0f));\n    defineParam(Point12, \"Point12\", float2(0.0f, 0.0f));\n    defineParam(Point13, \"Point13\", float2(0.0f, 0.0f));\n    defineParam(Point14, \"Point14\", float2(0.0f, 0.0f));\n    defineParam(Point15, \"Point15\", float2(0.0f, 0.0f));\n    defineParam(Point16, \"Point16\", float2(0.0f, 0.0f));\n    defineParam(Point17, \"Point17\", float2(0.0f, 0.0f));\n    defineParam(Point18, \"Point18\", float2(0.0f, 0.0f));\n    defineParam(Point19, \"Point19\", float2(0.0f, 0.0f));\n    defineParam(Point20, \"Point20\", float2(0.0f, 0.0f));\n    defineParam(Point21, \"Point21\", float2(0.0f, 0.0f));\n    defineParam(Point22, \"Point22\", float2(0.0f, 0.0f));\n    defineParam(Point23, \"Point23\", float2(0.0f, 0.0f));\n    defineParam(Point24, \"Point24\", float2(0.0f, 0.0f));\n    defineParam(Point25, \"Point25\", float2(0.0f, 0.0f));\n    defineParam(Point26, \"Point26\", float2(0.0f, 0.0f));\n    defineParam(Point27, \"Point27\", float2(0.0f, 0.0f));\n    defineParam(Point28, \"Point28\", float2(0.0f, 0.0f));\n    defineParam(Point29, \"Point29\", float2(0.0f, 0.0f));\n    defineParam(Point30, \"Point30\", float2(0.0f, 0.0f));\n    defineParam(Point31, \"Point31\", float2(0.0f, 0.0f));\n    defineParam(Point32, \"Point32\", float2(0.0f, 0.0f));\n    defineParam(Point33, \"Point33\", float2(0.0f, 0.0f));\n    defineParam(Point34, \"Point34\", float2(0.0f, 0.0f));\n    defineParam(Point35, \"Point35\", float2(0.0f, 0.0f));\n    defineParam(Point36, \"Point36\", float2(0.0f, 0.0f));\n    defineParam(Point37, \"Point37\", float2(0.0f, 0.0f));\n    defineParam(Point38, \"Point38\", float2(0.0f, 0.0f));\n    defineParam(Point39, \"Point39\", float2(0.0f, 0.0f));\n    defineParam(Point40, \"Point40\", float2(0.0f, 0.0f));\n    defineParam(Point41, \"Point41\", float2(0.0f, 0.0f));\n    defineParam(Point42, \"Point42\", float2(0.0f, 0.0f));\n    defineParam(Point43, \"Point43\", float2(0.0f, 0.0f));\n    defineParam(Point44, \"Point44\", float2(0.0f, 0.0f));\n    defineParam(Point45, \"Point45\", float2(0.0f, 0.0f));\n    defineParam(Point46, \"Point46\", float2(0.0f, 0.0f));\n    defineParam(Point47, \"Point47\", float2(0.0f, 0.0f));\n    defineParam(Point48, \"Point48\", float2(0.0f, 0.0f));\n    defineParam(Point49, \"Point49\", float2(0.0f, 0.0f));\n  \}\n\n  float dot2(float2 a, float2 b) \{\n    return a.x * b.x + a.y * b.y;\n  \}\n\n  float length2(float2 v) \{\n    return sqrt(v.x * v.x + v.y * v.y);\n  \}\n\n  float2 normalize2(float2 v) \{\n    float len = length2(v);\n    if (len > 0.0f) \{\n      return float2(v.x / len, v.y / len);\n    \} else \{\n      return float2(0.0f, 0.0f);\n    \}\n  \}\n\n  float2 evaluateSpline(float t)\n  \{\n    int numSegments = numControlPoints - 1;\n    float totalLength = (float)(numSegments);\n    float scaledT = t * totalLength;\n    int segment = (int)(floor(scaledT));\n    if (segment >= numSegments)\n      segment = numSegments - 1;\n    float localT = scaledT - (float)(segment);\n\n    int p0 = max(segment - 1, 0);\n    int p1 = segment;\n    int p2 = min(segment + 1, numControlPoints - 1);\n    int p3 = min(segment + 2, numControlPoints - 1);\n\n    float2 CP\[50];\n    CP\[0] = Point0;\n    CP\[1] = Point1;\n    CP\[2] = Point2;\n    CP\[3] = Point3;\n    CP\[4] = Point4;\n    CP\[5] = Point5;\n    CP\[6] = Point6;\n    CP\[7] = Point7;\n    CP\[8] = Point8;\n    CP\[9] = Point9;\n    CP\[10] = Point10;\n    CP\[11] = Point11;\n    CP\[12] = Point12;\n    CP\[13] = Point13;\n    CP\[14] = Point14;\n    CP\[15] = Point15;\n    CP\[16] = Point16;\n    CP\[17] = Point17;\n    CP\[18] = Point18;\n    CP\[19] = Point19;\n    CP\[20] = Point20;\n    CP\[21] = Point21;\n    CP\[22] = Point22;\n    CP\[23] = Point23;\n    CP\[24] = Point24;\n    CP\[25] = Point25;\n    CP\[26] = Point26;\n    CP\[27] = Point27;\n    CP\[28] = Point28;\n    CP\[29] = Point29;\n    CP\[30] = Point30;\n    CP\[31] = Point31;\n    CP\[32] = Point32;\n    CP\[33] = Point33;\n    CP\[34] = Point34;\n    CP\[35] = Point35;\n    CP\[36] = Point36;\n    CP\[37] = Point37;\n    CP\[38] = Point38;\n    CP\[39] = Point39;\n    CP\[40] = Point40;\n    CP\[41] = Point41;\n    CP\[42] = Point42;\n    CP\[43] = Point43;\n    CP\[44] = Point44;\n    CP\[45] = Point45;\n    CP\[46] = Point46;\n    CP\[47] = Point47;\n    CP\[48] = Point48;\n    CP\[49] = Point49;\n\n    float2 P0 = CP\[p0];\n    float2 P1 = CP\[p1];\n    float2 P2 = CP\[p2];\n    float2 P3 = CP\[p3];\n\n    // Linear interpolation\n    float2 linear = P1 + (P2 - P1) * localT;\n\n    // Catmull-Rom spline interpolation\n    float2 catmullRom = 0.5f * (\n      (2.0f * P1) +\n      (-P0 + P2) * localT +\n      (2.0f * P0 - 5.0f * P1 + 4.0f * P2 - P3) * localT * localT +\n      (-P0 + 3.0f * P1 - 3.0f * P2 + P3) * localT * localT * localT\n    );\n\n    // Interpolate between linear and Catmull-Rom based on tightness\n    return linear * tightness + catmullRom * (1.0f - tightness);\n  \}\n\n  float2 tangentSpline(float t)\n  \{\n    int numSegments = numControlPoints - 1;\n    float totalLength = (float)(numSegments);\n    float scaledT = t * totalLength;\n    int segment = (int)(floor(scaledT));\n    if (segment >= numSegments)\n      segment = numSegments - 1;\n    float localT = scaledT - (float)(segment);\n\n    int p0 = max(segment - 1, 0);\n    int p1 = segment;\n    int p2 = min(segment + 1, numControlPoints - 1);\n    int p3 = min(segment + 2, numControlPoints - 1);\n\n    float2 CP\[50];\n    CP\[0] = Point0;\n    CP\[1] = Point1;\n    CP\[2] = Point2;\n    CP\[3] = Point3;\n    CP\[4] = Point4;\n    CP\[5] = Point5;\n    CP\[6] = Point6;\n    CP\[7] = Point7;\n    CP\[8] = Point8;\n    CP\[9] = Point9;\n    CP\[10] = Point10;\n    CP\[11] = Point11;\n    CP\[12] = Point12;\n    CP\[13] = Point13;\n    CP\[14] = Point14;\n    CP\[15] = Point15;\n    CP\[16] = Point16;\n    CP\[17] = Point17;\n    CP\[18] = Point18;\n    CP\[19] = Point19;\n    CP\[20] = Point20;\n    CP\[21] = Point21;\n    CP\[22] = Point22;\n    CP\[23] = Point23;\n    CP\[24] = Point24;\n    CP\[25] = Point25;\n    CP\[26] = Point26;\n    CP\[27] = Point27;\n    CP\[28] = Point28;\n    CP\[29] = Point29;\n    CP\[30] = Point30;\n    CP\[31] = Point31;\n    CP\[32] = Point32;\n    CP\[33] = Point33;\n    CP\[34] = Point34;\n    CP\[35] = Point35;\n    CP\[36] = Point36;\n    CP\[37] = Point37;\n    CP\[38] = Point38;\n    CP\[39] = Point39;\n    CP\[40] = Point40;\n    CP\[41] = Point41;\n    CP\[42] = Point42;\n    CP\[43] = Point43;\n    CP\[44] = Point44;\n    CP\[45] = Point45;\n    CP\[46] = Point46;\n    CP\[47] = Point47;\n    CP\[48] = Point48;\n    CP\[49] = Point49;\n\n    float2 P0 = CP\[p0];\n    float2 P1 = CP\[p1];\n    float2 P2 = CP\[p2];\n    float2 P3 = CP\[p3];\n\n    // Linear tangent\n    float2 linearTangent = P2 - P1;\n// Catmull-Rom tangent (continued)\n    float2 catmullRomTangent = 0.5f * (\n      (-P0 + P2) +\n      2.0f * (2.0f * P0 - 5.0f * P1 + 4.0f * P2 - P3) * localT +\n      3.0f * (-P0 + 3.0f * P1 - 3.0f * P2 + P3) * localT * localT\n    );\n\n    // Interpolate between linear and Catmull-Rom tangents based on tightness\n    return normalize2(linearTangent * tightness + catmullRomTangent * (1.0f - tightness));\n  \}\n\n  float getWidth(float t)\n  \{\n    if (t < 0.5f) \{\n      return widthStart + (widthCenter - widthStart) * (t * 2.0f);\n    \} else \{\n      return widthCenter + (widthEnd - widthCenter) * ((t - 0.5f) * 2.0f);\n    \}\n  \}\n\n  float normalizedSamplePosition(int sampleIndex)\n  \{\n    if (!normalizeSamples) \{\n      return (float)sampleIndex / (float)numSamples;\n    \}\n\n    float totalLength = 0.0f;\n    float segmentLengths\[50];\n    int numSegments = numControlPoints - 1;\n\n    for (int i = 0; i < numSegments; ++i) \{\n      float2 p1 = evaluateSpline((float)i / (float)numSegments);\n      float2 p2 = evaluateSpline((float)(i + 1) / (float)numSegments);\n      float segmentLength = length2(p2 - p1);\n      segmentLengths\[i] = segmentLength;\n      totalLength += segmentLength;\n    \}\n\n    float targetLength = totalLength * (float)sampleIndex / (float)numSamples;\n    float currentLength = 0.0f;\n\n    for (int i = 0; i < numSegments; ++i) \{\n      if (currentLength + segmentLengths\[i] >= targetLength) \{\n        float segmentT = (targetLength - currentLength) / segmentLengths\[i];\n        return ((float)i + segmentT) / (float)numSegments;\n      \}\n      currentLength += segmentLengths\[i];\n    \}\n\n    return 1.0f;\n  \}\n\n  void process(int2 pos)\n  \{\n    float2 pixelPos = float2((float)(pos.x), (float)(pos.y));\n\n    float minDistSq = 1e10f;\n    float closest_t = 0.0f;\n    float2 closestPoint = pixelPos;\n    float2 closestTangent = float2(0.0f, 0.0f);\n\n    for (int i = 0; i <= numSamples; ++i)\n    \{\n      float t = normalizedSamplePosition(i);\n\n      float2 S_t = evaluateSpline(t);\n      float2 tangent = tangentSpline(t);\n\n      float2 diff = pixelPos - S_t;\n      float distSq = dot2(diff, diff);\n\n      if (distSq < minDistSq)\n      \{\n        minDistSq = distSq;\n        closestPoint = S_t;\n        closestTangent = tangent;\n        closest_t = t;\n      \}\n    \}\n\n    float dist = sqrt(minDistSq);\n    float width = getWidth(closest_t);\n\n    if (dist <= maxDistance * width)\n    \{\n      float U = closest_t;\n\n      float2 normal = float2(-closestTangent.y, closestTangent.x);\n      normal = normalize2(normal);\n\n      float side = dot2(pixelPos - closestPoint, normal);\n      float V = side / (maxDistance * width) * 0.5f + 0.5f; // Normalize V to \[0,1]\n\n      dst() = float4(U, V, 0.0f, 1.0f);\n    \}\n    else\n    \{\n      dst() = float4(0.0f, 0.0f, 0.0f, 0.0f);\n    \}\n  \}\n\};"
  rebuild ""
  "SplineUVMap_Number of Control Points" 11
  "SplineUVMap_Number of Samples" 400
  "SplineUVMap_Max Distance" 55
  SplineUVMap_Point0 {83 590}
  SplineUVMap_Point1 {125 948}
  SplineUVMap_Point2 {375 1167}
  SplineUVMap_Point3 {648 1029}
  SplineUVMap_Point4 {690 633}
  SplineUVMap_Point5 {821 483}
  SplineUVMap_Point6 {964 448}
  SplineUVMap_Point7 {1056 660}
  SplineUVMap_Point8 {1248 987}
  SplineUVMap_Point9 {1460 1087}
  SplineUVMap_Point10 {1791 1037}
  specifiedFormat true
  rebuild_finalise ""
  name BlinkScript
  selected true
  xpos 656
  ypos 25
 }
 Dot {
  name Dot_FW
  label "this dot is used to locate the Blinkscript"
  note_font_size 10
  xpos 690
  ypos 84
 }
set Na4607c00 [stack 0]
 Dot {
  name Dot10
  xpos 846
  ypos 147
 }
 FilterErode {
  size 0
  filter gaussian
  name FilterErode1
  xpos 812
  ypos 258
 }
push $Na4607c00
 Blur {
  size {{parent.UVBLUR}}
  name Blur1
  xpos 656
  ypos 122
 }
 Input {
  inputs 0
  name Image
  xpos 455
  ypos 168
  number 1
 }
 STMap {
  inputs 2
  uv rgb
  name STMap2
  xpos 656
  ypos 207
 }
 Merge2 {
  inputs 2
  operation mask
  name Merge1
  xpos 656
  ypos 264
 }
 Output {
  name Output1
  xpos 656
  ypos 308
 }
 Input {
  inputs 0
  name Roto
  xpos 987
  ypos 199
 }
end_group
Dot {
 name Dot2
 tile_color 0x84b9f2ff
 label "View Me"
 note_font_size 55
 xpos 1254
 ypos 697
}
FrameHold {
 firstFrame 29
 name FrameHold3
 xpos 1220
 ypos 731
}
Noise {
 inputs 0
 size {135.35 1}
 gain 0.825
 gamma 0.055
 translate {{curve x15 0 x200 1001} {curve x15 0}}
 center {1024 778}
 name Noise7
 xpos 1
 ypos 764
}
Transform {
 scale 3.2
 center {1024 778}
 name Transform26
 xpos 1
 ypos 799
}
Roto {
 inputs 0
 output alpha
 curves {{{v x3f99999a}
  {f 0}
  {n
   {layer Root
    {f 2097664}
    {t x44800000 x44428000}
    {a pt1x 0 pt1y 0 pt2x 0 pt2y 0 pt3x 0 pt3y 0 pt4x 0 pt4y 0 ptex00 0 ptex01 0 ptex02 0 ptex03 0 ptex10 0 ptex11 0 ptex12 0 ptex13 0 ptex20 0 ptex21 0 ptex22 0 ptex23 0 ptex30 0 ptex31 0 ptex32 0 ptex33 0 ptof1x 0 ptof1y 0 ptof2x 0 ptof2y 0 ptof3x 0 ptof3y 0 ptof4x 0 ptof4y 0 pterr 0 ptrefset 0 ptmot x40800000 ptref 0}
    {curvegroup OpenSpline1 1049088 bezier
     {{cc
       {f 1056800}
       {px x41400000
        {0 0}
        {{a osw
	  {{x41400000 1}}	 osf
	  {{x41400000 0}}}	x43a70000 x435e0000}
        {0 0}
        {0 0}
        {{a osw
	  {{x41400000 1}}	 osf
	  {{x41400000 0}}}	x43a90000 x446b8000}
        {0 0}
        {0 0}
        {{a osw
	  {{x41400000 1}}	 osf
	  {{x41400000 0}}}	x448ac000 x446a8000}
        {0 0}
        {0 0}
        {{a osw
	  {{x41400000 1}}	 osf
	  {{x41400000 0}}}	x448a4000 x44018000}
        {0 0}
        {0 0}
        {{a osw
	  {{x41400000 1}}	 osf
	  {{x41400000 0}}}	x44c14000 x44018000}
        {0 0}
        {0 0}
        {{a osw
	  {{x41400000 1}}	 osf
	  {{x41400000 0}}}	x44c44000 x44a48000}
        {0 0}
        {xc0800000 0}
        {{a osw
	  {{x41400000 1}}	 osf
	  {{x41400000 0}}}	x439d0000 x44a58000}
        {x40800000 0}}}     idem}
     {tx x41400000 x4461a492 x444e5b6e}
     {a osbe 0 osee 0 osw x41200000 osf 0 str 1 ltn x41400000 ltm x41400000 tt x41200000}}}}}}
 toolbox {selectAll {
  { selectAll str 1 ssx 1 ssy 1 sf 1 }
  { createBezier str 1 ssx 1 ssy 1 sf 1 sb 1 tt 4 }
  { createBezierCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createBSpline str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createEllipse str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangle str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createRectangleCusped str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { createOpenSpline str 1 ssx 1 ssy 1 sf 1 tt 10 }
  { brush str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { eraser src 2 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { clone src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { reveal src 3 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { dodge src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { burn src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { blur src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { sharpen src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
  { smear src 1 str 1 ssx 1 ssy 1 sf 1 sb 1 }
} }
 toolbar_brush_hardness 0.200000003
 toolbar_source_transform_scale {1 1}
 toolbar_source_transform_center {320 240}
 colorOverlay {0 0 0 0}
 lifetime_type "all frames"
 lifetime_start 12
 lifetime_end 12
 motionblur_shutter_offset_type centred
 name Roto23
 xpos 201
 ypos 789
}
Group {
 inputs 2
 name CA_FlowWarp11
 tile_color 0x4c65ffff
 note_font "Verdana Bold"
 note_font_size 12
 note_font_color 0xe0cc30ff
 xpos 1
 ypos 834
 addUserKnob {20 User}
 addUserKnob {22 SampleRoto l "Sample Roto" T "import nuke\nimport nuke.rotopaint as rp\n\n# Function to retrieve points from the Roto node's shapes and strokes\ndef get_roto_points(roto_node):\n    curves_knob = roto_node\['curves']\n    points = \[]\n    processed_elements = set()  # To track processed elements\n\n    # Access the root layer of the Roto node\n    root_layer = curves_knob.rootLayer\n\n    # Function to parse the layer and find shapes and strokes\n    def parse_layer(layer):\n        for element in layer:\n            element_id = id(element)  # Unique identifier for each element\n\n            # Check if the element is a Shape and not already processed\n            if isinstance(element, rp.Shape) and element_id not in processed_elements:\n                # print(f\"Processing shape: \{element.name\}\")\n                processed_elements.add(element_id)  # Mark element as processed\n\n                # Loop through the control points (CVs) in the shape\n                for point_idx, point in enumerate(element):\n                    frame = nuke.frame()\n                    # Get the position of the control vertex (center point)\n                    pos = point.center.getPosition(frame)\n                    points.append((pos\[0], pos\[1]))\n                    # Removed print statement here\n\n            # If the element is a Layer, process its contents\n            elif isinstance(element, rp.Layer) and element_id not in processed_elements:\n                # print(f\"Processing layer: \{element.name\}\")\n                processed_elements.add(element_id)  # Mark layer as processed\n                parse_layer(element)  # Recursively parse nested layers\n\n    # Parse the root layer to extract points\n    parse_layer(root_layer)\n    \n    return points\n\n# Main function to run the script and update the BlinkScript node\ndef main():\n    # Get the current node (the group node)\n    current_node = nuke.thisNode()\n\n    # Check if there is an input connected to the node (assuming input 0 is the roto node)\n    roto_node = current_node.input(0)\n    \n    if not roto_node or roto_node.Class() not in \['Roto', 'RotoPaint']:\n        nuke.message(\"Please connect a Roto or RotoPaint node to the current node.\")\n        return\n\n    # Get the points from the connected Roto or RotoPaint node\n    # print(f\"Processing connected node: \{roto_node.name()\}\")\n    roto_points = get_roto_points(roto_node)\n    \n    if not roto_points:\n        nuke.message(\"No points found in the connected Roto node.\")\n        return\n    else:\n        # Begin the group to access internal nodes\n        current_node.begin()\n\n        # Find the BlinkScript node inside the group\n        blinkscript_node = None\n        for n in nuke.allNodes():\n            if n.Class() == 'BlinkScript':\n                blinkscript_node = n\n                break\n        if blinkscript_node is None:\n            nuke.message(\"BlinkScript node not found inside the group.\")\n            current_node.end()\n            return\n\n        # Update the BlinkScript node parameters\n        # Set \"Number of Control Points\" to the number of points retrieved\n        blinkscript_node\['SplineUVMap_Number of Control Points'].setValue(len(roto_points))\n\n        # Update the positions of the points\n        max_points = 30  # Assuming the BlinkScript node has parameters up to Point29\n        for idx, point in enumerate(roto_points):\n            if idx >= max_points:\n                nuke.warning(f\"BlinkScript node supports a maximum of \{max_points\} points. Extra points are ignored.\")\n                break\n            # The point knobs are named \"SplineUVMap_Point0\", \"SplineUVMap_Point1\", etc.\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue(point)\n            else:\n                nuke.warning(f\"BlinkScript node does not have knob \{knob_name\}\")\n\n        # For any remaining Point knobs, set them to (0, 0)\n        for idx in range(len(roto_points), max_points):\n            knob_name = f\"SplineUVMap_Point\{idx\}\"\n            if knob_name in blinkscript_node.knobs():\n                blinkscript_node\[knob_name].setValue((0.0, 0.0))\n\n        # End the group\n        current_node.end()\n\n# Execute the main function\nmain()\n" +STARTLINE}
 addUserKnob {41 "SplineUVMap_Number of Samples_1" l "Number of Samples" T "BlinkScript12.SplineUVMap_Number of Samples"}
 addUserKnob {41 "SplineUVMap_Max Distance" l "Max Distance" T "BlinkScript12.SplineUVMap_Max Distance"}
 addUserKnob {7 UVBLUR l "UV Blur" R 0 50}
 UVBLUR 8.2
 addUserKnob {41 "SplineUVMap_Curve Tightness" l "Curve Tightness" T "BlinkScript12.SplineUVMap_Curve Tightness"}
 addUserKnob {41 "SplineUVMap_Normalize Samples" l "Normalize Samples" T "BlinkScript12.SplineUVMap_Normalize Samples"}
 addUserKnob {26 explanation l Samples T "If you want your\nsamples evenly spread,\nnormalize them"}
 addUserKnob {26 ""}
 addUserKnob {41 "SplineUVMap_Number of Control Points" l "Number of Control Points" T "BlinkScript12.SplineUVMap_Number of Control Points"}
 addUserKnob {26 _1 l Info: T "Auto detected from Sample Roto.  \nYou can put custom control points\nin group if you want."}
 addUserKnob {26 ""}
 addUserKnob {26 tapers l " " T "Taper Controls"}
 addUserKnob {41 "SplineUVMap_Width Start" l "Width Start" T "BlinkScript12.SplineUVMap_Width Start"}
 addUserKnob {41 "SplineUVMap_Width Center" l "Width Center" T "BlinkScript12.SplineUVMap_Width Center"}
 addUserKnob {41 "SplineUVMap_Width End" l "Width End" T "BlinkScript12.SplineUVMap_Width End"}
 addUserKnob {26 ""}
 addUserKnob {26 Edge l "" -STARTLINE T "Edge Details"}
 addUserKnob {41 size l "Erode Edge" T FilterErode1.size}
 addUserKnob {41 filter l "Edge Filter" T FilterErode1.filter}
 addUserKnob {26 ""}
 addUserKnob {26 compacademy l " " T "For more:\nTools, Training, Epic Stock Footage:\n\nwww.compositingacademy.com\n\nMade in 2024"}
}
 BlinkScript {
  inputs 0
  recompileCount 8
  KernelDescription "3 \"SplineUVMap\" iterate pixelWise 1366c3d567aa09d8c61f9ee91dc0143cc0faef37ccac2db0ad333a13d81bbc31 1 \"dst\" Write Point 38 \"Number of Control Points\" Int 1 BAAAAA== \"Number of Samples\" Int 1 ZAAAAA== \"Max Distance\" Float 1 AABIQg== \"Curve Tightness\" Float 1 AAAAAA== \"Width Start\" Float 1 AACAPw== \"Width Center\" Float 1 AACAPw== \"Width End\" Float 1 AACAPw== \"Normalize Samples\" Bool 1 AA== \"Point0\" Float 2 AAAAAAAAAAA= \"Point1\" Float 2 AAAAAAAAAAA= \"Point2\" Float 2 AAAAAAAAAAA= \"Point3\" Float 2 AAAAAAAAAAA= \"Point4\" Float 2 AAAAAAAAAAA= \"Point5\" Float 2 AAAAAAAAAAA= \"Point6\" Float 2 AAAAAAAAAAA= \"Point7\" Float 2 AAAAAAAAAAA= \"Point8\" Float 2 AAAAAAAAAAA= \"Point9\" Float 2 AAAAAAAAAAA= \"Point10\" Float 2 AAAAAAAAAAA= \"Point11\" Float 2 AAAAAAAAAAA= \"Point12\" Float 2 AAAAAAAAAAA= \"Point13\" Float 2 AAAAAAAAAAA= \"Point14\" Float 2 AAAAAAAAAAA= \"Point15\" Float 2 AAAAAAAAAAA= \"Point16\" Float 2 AAAAAAAAAAA= \"Point17\" Float 2 AAAAAAAAAAA= \"Point18\" Float 2 AAAAAAAAAAA= \"Point19\" Float 2 AAAAAAAAAAA= \"Point20\" Float 2 AAAAAAAAAAA= \"Point21\" Float 2 AAAAAAAAAAA= \"Point22\" Float 2 AAAAAAAAAAA= \"Point23\" Float 2 AAAAAAAAAAA= \"Point24\" Float 2 AAAAAAAAAAA= \"Point25\" Float 2 AAAAAAAAAAA= \"Point26\" Float 2 AAAAAAAAAAA= \"Point27\" Float 2 AAAAAAAAAAA= \"Point28\" Float 2 AAAAAAAAAAA= \"Point29\" Float 2 AAAAAAAAAAA= 38 \"numControlPoints\" 1 1 Default \"numSamples\" 1 1 Default \"maxDistance\" 1 1 Default \"tightness\" 1 1 Default \"widthStart\" 1 1 Default \"widthCenter\" 1 1 Default \"widthEnd\" 1 1 Default \"normalizeSamples\" 1 1 Default \"Point0\" 2 1 Default \"Point1\" 2 1 Default \"Point2\" 2 1 Default \"Point3\" 2 1 Default \"Point4\" 2 1 Default \"Point5\" 2 1 Default \"Point6\" 2 1 Default \"Point7\" 2 1 Default \"Point8\" 2 1 Default \"Point9\" 2 1 Default \"Point10\" 2 1 Default \"Point11\" 2 1 Default \"Point12\" 2 1 Default \"Point13\" 2 1 Default \"Point14\" 2 1 Default \"Point15\" 2 1 Default \"Point16\" 2 1 Default \"Point17\" 2 1 Default \"Point18\" 2 1 Default \"Point19\" 2 1 Default \"Point20\" 2 1 Default \"Point21\" 2 1 Default \"Point22\" 2 1 Default \"Point23\" 2 1 Default \"Point24\" 2 1 Default \"Point25\" 2 1 Default \"Point26\" 2 1 Default \"Point27\" 2 1 Default \"Point28\" 2 1 Default \"Point29\" 2 1 Default 0"
  EncodedSource "1 9260 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"
  rebuild ""
  "SplineUVMap_Number of Control Points" 7
  "SplineUVMap_Number of Samples" 300
  "SplineUVMap_Max Distance" 43
  "SplineUVMap_Curve Tightness" 1
  "SplineUVMap_Normalize Samples" true
  SplineUVMap_Point0 {334 222}
  SplineUVMap_Point1 {338 942}
  SplineUVMap_Point2 {1110 938}
  SplineUVMap_Point3 {1106 518}
  SplineUVMap_Point4 {1546 518}
  SplineUVMap_Point5 {1570 1316}
  SplineUVMap_Point6 {314 1324}
  protectKernelWhenPublishing true
  specifiedFormat true
  rebuild_finalise ""
  name BlinkScript12
  selected true
  xpos 656
  ypos 54
 }
set Na4123000 [stack 0]
 Dot {
  name Dot1
  xpos 846
  ypos 147
 }
 FilterErode {
  size 37
  name FilterErode1
  xpos 812
  ypos 258
 }
push $Na4123000
 Blur {
  size {{parent.UVBLUR}}
  name Blur1
  xpos 656
  ypos 122
 }
 Input {
  inputs 0
  name Image
  xpos 455
  ypos 168
  number 1
 }
 STMap {
  inputs 2
  uv rgb
  name STMap2
  xpos 656
  ypos 207
 }
 Merge2 {
  inputs 2
  operation mask
  name Merge1
  xpos 656
  ypos 264
 }
 Output {
  name Output1
  xpos 656
  ypos 308
 }
 Input {
  inputs 0
  name Roto
  xpos 987
  ypos 199
 }
end_group
Grade {
 gamma 0.45
 name Grade26
 xpos 1
 ypos 862
}
Grade {
 white {0.196889 1 0.423157 1}
 white_panelDropped true
 gamma 2.15
 name Grade23
 xpos 1
 ypos 886
}
set Naef8b800 [stack 0]
Group {
 name Exp_Glow3
 tile_color 0x9bd2ff
 xpos -136
 ypos 923
 addUserKnob {20 User}
 addUserKnob {7 blur R 0 6}
 blur 1
 addUserKnob {41 value l spread T __SPREAD__.value}
 addUserKnob {41 value_1 l brightness T Brightness.value}
 addUserKnob {26 ""}
 addUserKnob {7 lo l threshold_value R 0 8}
}
 Input {
  inputs 0
  name Img
  xpos 410
  ypos -86
 }
 Multiply {
  channels rgb
  value 0.3
  name Brightness
  xpos 410
  ypos 64
 }
set Naefc2000 [stack 0]
 Blur {
  channels rgba
  size {{__BLUR__8.size*2}}
  name __BLUR__9
  xpos 839
  ypos 327
 }
 Multiply {
  channels rgba
  value {{__SPREAD__8.value*__SPREAD__.value i}}
  name __SPREAD__9
  xpos 845
  ypos 394
 }
push $Naefc2000
 Blur {
  channels rgba
  size {{__BLUR__7.size*2 i}}
  name __BLUR__8
  xpos 733
  ypos 314
 }
 Multiply {
  channels rgba
  value {{__SPREAD__7.value*__SPREAD__.value i}}
  name __SPREAD__8
  xpos 733
  ypos 391
 }
push $Naefc2000
 Blur {
  channels rgba
  size {{__BLUR__6.size*2 i}}
  name __BLUR__7
  xpos 622
  ypos 316
 }
 Multiply {
  channels rgba
  value {{__SPREAD__6.value*__SPREAD__.value i}}
  name __SPREAD__7
  xpos 622
  ypos 393
 }
push $Naefc2000
 Blur {
  channels rgba
  size {{__BLUR__5.size*2 i}}
  name __BLUR__6
  xpos 521
  ypos 315
 }
 Multiply {
  channels rgba
  value {{__SPREAD__5.value*__SPREAD__.value i}}
  name __SPREAD__6
  xpos 521
  ypos 396
 }
push $Naefc2000
 Blur {
  channels rgba
  size {{__BLUR__4.size*2 i}}
  name __BLUR__5
  xpos 419
  ypos 319
 }
 Multiply {
  channels rgba
  value {{__SPREAD__4.value*__SPREAD__.value i}}
  name __SPREAD__5
  xpos 419
  ypos 395
 }
push $Naefc2000
 Blur {
  channels rgba
  size {{__BLUR__3.size*2 i}}
  name __BLUR__4
  xpos 320
  ypos 318
 }
 Multiply {
  channels rgba
  value {{__SPREAD__3.value*__SPREAD__.value i}}
  name __SPREAD__4
  xpos 320
  ypos 392
 }
push $Naefc2000
 Blur {
  channels rgba
  size {{__BLUR__2.size*2 i}}
  name __BLUR__3
  xpos 217
  ypos 318
 }
 Multiply {
  channels rgba
  value {{__SPREAD__2.value*__SPREAD__.value i}}
  name __SPREAD__3
  xpos 217
  ypos 391
 }
push $Naefc2000
 Blur {
  channels rgba
  size {{__BLUR__1.size*2 i}}
  name __BLUR__2
  xpos 110
  ypos 317
 }
 Multiply {
  channels rgba
  value {{__SPREAD__1.value*__SPREAD__.value i}}
  name __SPREAD__2
  xpos 110
  ypos 391
 }
push 0
push $Naefc2000
 Blur {
  channels rgb
  size {{parent.blur i}}
  name __BLUR__
  xpos -88
  ypos 317
 }
 Multiply {
  channels rgba
  value 1.12
  name __SPREAD__
  xpos -88
  ypos 389
 }
push $Naefc2000
 Blur {
  channels rgb
  size {{__BLUR__.size*2 i}}
  name __BLUR__1
  xpos 8
  ypos 317
 }
 Multiply {
  channels rgba
  value {{__SPREAD__.value*__SPREAD__.value i}}
  name __SPREAD__1
  xpos 8
  ypos 389
 }
 Merge2 {
  inputs 10+1
  operation plus
  Achannels rgb
  Bchannels rgb
  output rgb
  name Plus
  xpos 410
  ypos 614
 }
 Output {
  name Output1
  xpos 410
  ypos 764
 }
end_group
push $Naef8b800
Merge2 {
 inputs 2
 operation plus
 name Merge9
 xpos 1
 ypos 932
}
Grade {
 white 2.24
 multiply 1.98
 name Grade24
 xpos 1
 ypos 1010
}
StickyNote {
 inputs 0
 name StickyNote11
 tile_color 0x7ba8ccff
 label "start here"
 note_font_size 66
 xpos -36
 ypos -674
}
ColorWheel {
 inputs 0
 gamma 0.45
 name ColorWheel4
 selected true
 xpos -965
 ypos 558
}
Viewer {
 frame_range 15-500
 viewerProcess "sRGB (ACES)"
 monitorOutNDISenderName "NukeX - Script_Updated - Viewer1"
 name Viewer1
 xpos -1163
 ypos 724
}
